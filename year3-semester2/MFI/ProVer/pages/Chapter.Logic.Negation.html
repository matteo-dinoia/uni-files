<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Negation and decidability | Introduction to Program Verification in Agda</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Negation and decidability" />
<meta property="og:locale" content="en_US" />
<meta property="og:site_name" content="Introduction to Program Verification in Agda" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Negation and decidability" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Negation and decidability","url":"/pages/Chapter.Logic.Negation.html"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/Agda.css">
  <script src="../assets/js/mathjax.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="../assets/js/codereveal.js"></script>
  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Introduction to Program Verification in Agda" /><!-- <script src="/assets/js/clipboard.min.js"></script> -->
  <!-- <script src="/assets/js/codeselect.js"></script> -->
</head>
<body>

<header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="../index.html">Introduction to Program Verification in Agda</a>
    

    <nav class="site-nav">
      <a href="https://agda.readthedocs.io/en/latest/">AGDA DOCS</a>
    </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <ul class="menu">
  <li>
    <a href="Chapter.Logic.Connectives.html">‹ Logical connectives and constants</a></li>
  <li>
    <a href="Chapter.Logic.Existential.html">Existential quantification ›</a></li>
</ul>
  <header class="post-header">
    <h1 class="post-title">Negation and decidability</h1>
  </header>

  <div class="post-content">
    <pre class="Agda"><a id="113" class="Keyword">module</a> <a id="120" href="Chapter.Logic.Negation.html" class="Module">Chapter.Logic.Negation</a> <a id="143" class="Keyword">where</a>
</pre>
<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="170" class="Keyword">open</a> <a id="175" class="Keyword">import</a> <a id="182" href="Library.Bool.html" class="Module">Library.Bool</a>
<a id="195" class="Keyword">open</a> <a id="200" class="Keyword">import</a> <a id="207" href="Library.Nat.html" class="Module">Library.Nat</a>
<a id="219" class="Keyword">open</a> <a id="224" class="Keyword">import</a> <a id="231" href="Library.List.html" class="Module">Library.List</a>
<a id="244" class="Keyword">open</a> <a id="249" class="Keyword">import</a> <a id="256" href="Library.Fun.html" class="Module">Library.Fun</a>
<a id="268" class="Keyword">open</a> <a id="273" class="Keyword">import</a> <a id="280" href="Library.Equality.html" class="Module">Library.Equality</a>
<a id="297" class="Keyword">open</a> <a id="302" class="Keyword">import</a> <a id="309" href="Chapter.Logic.Connectives.html" class="Module">Chapter.Logic.Connectives</a>
</pre>
<h2 id="constructive-negation">Constructive negation</h2>

<p>In constructive logic, the <code class="language-plaintext highlighter-rouge">⊥</code> data type has a fundamental role
since it allows us to define negation. Showing that the <em>negation</em>
of a proposition <code class="language-plaintext highlighter-rouge">A</code> holds amounts to showing that a proof of <code class="language-plaintext highlighter-rouge">A</code>
can be turned into a proof of <code class="language-plaintext highlighter-rouge">⊥</code>.</p>

<pre class="Agda"><a id="¬_"></a><a id="603" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬_</a> <a id="606" class="Symbol">:</a> <a id="608" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="612" class="Symbol">-&gt;</a> <a id="615" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="619" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬_</a> <a id="622" href="Chapter.Logic.Negation.html#622" class="Bound">A</a> <a id="624" class="Symbol">=</a> <a id="626" href="Chapter.Logic.Negation.html#622" class="Bound">A</a> <a id="628" class="Symbol">-&gt;</a> <a id="631" href="Chapter.Logic.Connectives.html#4889" class="Datatype">⊥</a>
</pre>
<p>We will make a rather extensive use of negation in the following
chapters. For the time being, we prove a few laws related to
negation. The first one is <strong>contradiction</strong>, namely the fact that
if we have both a proof of <code class="language-plaintext highlighter-rouge">A</code> and a proof of <code class="language-plaintext highlighter-rouge">¬ A</code> then we can
derive a proof of <code class="language-plaintext highlighter-rouge">⊥</code>. Recalling that the negation of <code class="language-plaintext highlighter-rouge">A</code> is defined
as a function that turns a proof of <code class="language-plaintext highlighter-rouge">A</code> into a proof of <code class="language-plaintext highlighter-rouge">⊥</code>, we see
that contradiction simply amounts to function application.</p>

<pre class="Agda"><a id="contradiction"></a><a id="1096" href="Chapter.Logic.Negation.html#1096" class="Function">contradiction</a> <a id="1110" class="Symbol">:</a> <a id="1112" class="Symbol">∀{</a><a id="1114" href="Chapter.Logic.Negation.html#1114" class="Bound">A</a> <a id="1116" class="Symbol">:</a> <a id="1118" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1121" class="Symbol">}</a> <a id="1123" class="Symbol">-&gt;</a> <a id="1126" href="Chapter.Logic.Negation.html#1114" class="Bound">A</a> <a id="1128" class="Symbol">-&gt;</a> <a id="1131" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="1133" href="Chapter.Logic.Negation.html#1114" class="Bound">A</a> <a id="1135" class="Symbol">-&gt;</a> <a id="1138" href="Chapter.Logic.Connectives.html#4889" class="Datatype">⊥</a>
<a id="1140" href="Chapter.Logic.Negation.html#1096" class="Function">contradiction</a> <a id="1154" href="Chapter.Logic.Negation.html#1154" class="Bound">p</a> <a id="1156" href="Chapter.Logic.Negation.html#1156" class="Bound">¬p</a> <a id="1159" class="Symbol">=</a> <a id="1161" href="Chapter.Logic.Negation.html#1156" class="Bound">¬p</a> <a id="1164" href="Chapter.Logic.Negation.html#1154" class="Bound">p</a>
</pre>
<p>Recalling that in Agda the type <code class="language-plaintext highlighter-rouge">¬ A</code> is <em>defined</em> to be the same as
the type <code class="language-plaintext highlighter-rouge">A -&gt; ⊥</code>, the type of <code class="language-plaintext highlighter-rouge">contradiction</code> can also be written
as <code class="language-plaintext highlighter-rouge">∀{A : Set} -&gt; A -&gt; ¬ ¬ A</code>. This is one of the so-called “double
negation” laws.</p>

<pre class="Agda"><a id="double-negation"></a><a id="1396" href="Chapter.Logic.Negation.html#1396" class="Function">double-negation</a> <a id="1412" class="Symbol">:</a> <a id="1414" class="Symbol">∀{</a><a id="1416" href="Chapter.Logic.Negation.html#1416" class="Bound">A</a> <a id="1418" class="Symbol">:</a> <a id="1420" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1423" class="Symbol">}</a> <a id="1425" class="Symbol">-&gt;</a> <a id="1428" href="Chapter.Logic.Negation.html#1416" class="Bound">A</a> <a id="1430" class="Symbol">-&gt;</a> <a id="1433" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="1435" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="1437" href="Chapter.Logic.Negation.html#1416" class="Bound">A</a>
<a id="1439" href="Chapter.Logic.Negation.html#1396" class="Function">double-negation</a> <a id="1455" class="Symbol">=</a> <a id="1457" href="Chapter.Logic.Negation.html#1096" class="Function">contradiction</a>
</pre>
<p>In classical logic, the inverse implication <code class="language-plaintext highlighter-rouge">¬ ¬ A -&gt; A</code> is also
assumed to be true. However, this implication is not provable in
constructive logic (it is instructive to <strong>attempt</strong> proving this
property).</p>

<p>Another interesting law concerning negation is <strong>contraposition</strong>,
asserting that if <code class="language-plaintext highlighter-rouge">A</code> implies <code class="language-plaintext highlighter-rouge">B</code>, then <code class="language-plaintext highlighter-rouge">¬ B</code> implies <code class="language-plaintext highlighter-rouge">¬ A</code>.</p>

<pre class="Agda"><a id="contrapositive"></a><a id="1817" href="Chapter.Logic.Negation.html#1817" class="Function">contrapositive</a> <a id="1832" class="Symbol">:</a> <a id="1834" class="Symbol">∀{</a><a id="1836" href="Chapter.Logic.Negation.html#1836" class="Bound">A</a> <a id="1838" href="Chapter.Logic.Negation.html#1838" class="Bound">B</a> <a id="1840" class="Symbol">:</a> <a id="1842" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1845" class="Symbol">}</a> <a id="1847" class="Symbol">-&gt;</a> <a id="1850" class="Symbol">(</a><a id="1851" href="Chapter.Logic.Negation.html#1836" class="Bound">A</a> <a id="1853" class="Symbol">-&gt;</a> <a id="1856" href="Chapter.Logic.Negation.html#1838" class="Bound">B</a><a id="1857" class="Symbol">)</a> <a id="1859" class="Symbol">-&gt;</a> <a id="1862" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="1864" href="Chapter.Logic.Negation.html#1838" class="Bound">B</a> <a id="1866" class="Symbol">-&gt;</a> <a id="1869" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="1871" href="Chapter.Logic.Negation.html#1836" class="Bound">A</a>
<a id="1873" href="Chapter.Logic.Negation.html#1817" class="Function">contrapositive</a> <a id="1888" href="Chapter.Logic.Negation.html#1888" class="Bound">f</a> <a id="1890" href="Chapter.Logic.Negation.html#1890" class="Bound">p</a> <a id="1892" href="Chapter.Logic.Negation.html#1892" class="Bound">q</a> <a id="1894" class="Symbol">=</a> <a id="1896" href="Chapter.Logic.Negation.html#1890" class="Bound">p</a> <a id="1898" class="Symbol">(</a><a id="1899" href="Chapter.Logic.Negation.html#1888" class="Bound">f</a> <a id="1901" href="Chapter.Logic.Negation.html#1892" class="Bound">q</a><a id="1902" class="Symbol">)</a>
</pre>
<p>Observe that we define <code class="language-plaintext highlighter-rouge">contrapositive</code> as a function with three
arguments <code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">q</code>, while its type appears to have only two
arguments, one of type <code class="language-plaintext highlighter-rouge">A -&gt; B</code> (that would be <code class="language-plaintext highlighter-rouge">f</code>) and the other of
type <code class="language-plaintext highlighter-rouge">¬ B</code> (that would be <code class="language-plaintext highlighter-rouge">p</code>). However, the type <code class="language-plaintext highlighter-rouge">¬ A</code> is actually
the type <code class="language-plaintext highlighter-rouge">A -&gt; ⊥</code>, so <code class="language-plaintext highlighter-rouge">contrapositive</code> can be seen as also having a
third argument of type <code class="language-plaintext highlighter-rouge">A</code>, that would be <code class="language-plaintext highlighter-rouge">q</code>.</p>

<p>Using <code class="language-plaintext highlighter-rouge">contrapositive</code> and <code class="language-plaintext highlighter-rouge">double-negation</code> we can prove that
<em>triple</em> negation implies <em>single</em> negation.</p>

<pre class="Agda"><a id="triple-negation"></a><a id="2408" href="Chapter.Logic.Negation.html#2408" class="Function">triple-negation</a> <a id="2424" class="Symbol">:</a> <a id="2426" class="Symbol">∀{</a><a id="2428" href="Chapter.Logic.Negation.html#2428" class="Bound">A</a> <a id="2430" class="Symbol">:</a> <a id="2432" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="2435" class="Symbol">}</a> <a id="2437" class="Symbol">-&gt;</a> <a id="2440" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="2442" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="2444" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="2446" href="Chapter.Logic.Negation.html#2428" class="Bound">A</a> <a id="2448" class="Symbol">-&gt;</a> <a id="2451" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="2453" href="Chapter.Logic.Negation.html#2428" class="Bound">A</a>
<a id="2455" href="Chapter.Logic.Negation.html#2408" class="Function">triple-negation</a> <a id="2471" class="Symbol">=</a> <a id="2473" href="Chapter.Logic.Negation.html#1817" class="Function">contrapositive</a> <a id="2488" href="Chapter.Logic.Negation.html#1396" class="Function">double-negation</a>
</pre>
<h2 id="decidability">Decidability</h2>

<p>In classical logic it is common to assume the validity of the
<em>excluded middle</em> principle, namely that <code class="language-plaintext highlighter-rouge">¬ A ∨ A</code> is true for every
proposition <code class="language-plaintext highlighter-rouge">A</code>. As we know from the <a href="Chapter.Logic.Connectives.html">previous
chapter</a>, in constructive logic, a
proof of a disjunction <code class="language-plaintext highlighter-rouge">¬ A ∨ A</code> embeds either a proof of <code class="language-plaintext highlighter-rouge">¬ A</code> or a
proof of <code class="language-plaintext highlighter-rouge">A</code>, hence it may very well be the case that we are unable
to prove <code class="language-plaintext highlighter-rouge">¬ A ∨ A</code> if we cannot find either a proof of <code class="language-plaintext highlighter-rouge">¬ A</code> or a
proof of <code class="language-plaintext highlighter-rouge">A</code>. The propositions for which we are able to prove <code class="language-plaintext highlighter-rouge">¬ A ∨
A</code> are said to be <strong>decidable</strong>.</p>

<pre class="Agda"><a id="Decidable"></a><a id="3081" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="3091" class="Symbol">:</a> <a id="3093" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="3097" class="Symbol">-&gt;</a> <a id="3100" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="3104" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="3114" href="Chapter.Logic.Negation.html#3114" class="Bound">A</a> <a id="3116" class="Symbol">=</a> <a id="3118" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="3120" href="Chapter.Logic.Negation.html#3114" class="Bound">A</a> <a id="3122" href="Chapter.Logic.Connectives.html#3884" class="Datatype Operator">∨</a> <a id="3124" href="Chapter.Logic.Negation.html#3114" class="Bound">A</a>
</pre>
<p>As an example of decidable property, consider the problem of
determining whether two boolean values are equal or not.  This can
be shown by considering all the possible cases, which are finite.</p>

<pre class="Agda"><a id="Bool-eq-decidable"></a><a id="3330" href="Chapter.Logic.Negation.html#3330" class="Function">Bool-eq-decidable</a> <a id="3348" class="Symbol">:</a> <a id="3350" class="Symbol">∀(</a><a id="3352" href="Chapter.Logic.Negation.html#3352" class="Bound">x</a> <a id="3354" href="Chapter.Logic.Negation.html#3354" class="Bound">y</a> <a id="3356" class="Symbol">:</a> <a id="3358" href="Library.Bool.html#33" class="Datatype">Bool</a><a id="3362" class="Symbol">)</a> <a id="3364" class="Symbol">-&gt;</a> <a id="3367" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="3377" class="Symbol">(</a><a id="3378" href="Chapter.Logic.Negation.html#3352" class="Bound">x</a> <a id="3380" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="3383" href="Chapter.Logic.Negation.html#3354" class="Bound">y</a><a id="3384" class="Symbol">)</a>
<a id="3386" href="Chapter.Logic.Negation.html#3330" class="Function">Bool-eq-decidable</a> <a id="3404" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="3410" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="3416" class="Symbol">=</a> <a id="3418" href="Chapter.Logic.Connectives.html#3933" class="InductiveConstructor">inr</a> <a id="3422" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="3427" href="Chapter.Logic.Negation.html#3330" class="Function">Bool-eq-decidable</a> <a id="3445" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="3451" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="3457" class="Symbol">=</a> <a id="3459" href="Chapter.Logic.Connectives.html#3914" class="InductiveConstructor">inl</a> <a id="3463" class="Symbol">λ</a> <a id="3465" class="Symbol">()</a>
<a id="3468" href="Chapter.Logic.Negation.html#3330" class="Function">Bool-eq-decidable</a> <a id="3486" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="3492" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="3498" class="Symbol">=</a> <a id="3500" href="Chapter.Logic.Connectives.html#3914" class="InductiveConstructor">inl</a> <a id="3504" class="Symbol">λ</a> <a id="3506" class="Symbol">()</a>
<a id="3509" href="Chapter.Logic.Negation.html#3330" class="Function">Bool-eq-decidable</a> <a id="3527" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="3533" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="3539" class="Symbol">=</a> <a id="3541" href="Chapter.Logic.Connectives.html#3933" class="InductiveConstructor">inr</a> <a id="3545" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
</pre>
<p>Note that we use the constructor <code class="language-plaintext highlighter-rouge">inr</code> (“inject right”) for
representing a positive answer to the question “is <code class="language-plaintext highlighter-rouge">x</code> equal to
<code class="language-plaintext highlighter-rouge">y</code>?” and <code class="language-plaintext highlighter-rouge">inl</code> (“inject left”) for representing a negative answer.</p>

<!--

For readability purposes, it may be appropriate to give
these constructors more evocative names, such as `yes` and `no`. We
can do so (without defining an *ad hoc* `Decidable` data type) by
means of **pattern synonyms**.

<pre class="Agda"><a id="3980" class="Keyword">pattern</a> <a id="yes"></a><a id="3988" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="3992" href="Chapter.Logic.Negation.html#4000" class="Bound">x</a> <a id="3994" class="Symbol">=</a> <a id="3996" href="Chapter.Logic.Connectives.html#3933" class="InductiveConstructor">inr</a> <a id="4000" href="Chapter.Logic.Negation.html#4000" class="Bound">x</a>
<a id="4002" class="Keyword">pattern</a> <a id="no"></a><a id="4010" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a>  <a id="4014" href="Chapter.Logic.Negation.html#4022" class="Bound">x</a> <a id="4016" class="Symbol">=</a> <a id="4018" href="Chapter.Logic.Connectives.html#3914" class="InductiveConstructor">inl</a> <a id="4022" href="Chapter.Logic.Negation.html#4022" class="Bound">x</a>
</pre>
With these declarations, we may write `Bool-eq-decidable` as follows.

<pre class="Agda"><a id="Bool-eq-decidable₁"></a><a id="4104" href="Chapter.Logic.Negation.html#4104" class="Function">Bool-eq-decidable₁</a> <a id="4123" class="Symbol">:</a> <a id="4125" class="Symbol">∀(</a><a id="4127" href="Chapter.Logic.Negation.html#4127" class="Bound">x</a> <a id="4129" href="Chapter.Logic.Negation.html#4129" class="Bound">y</a> <a id="4131" class="Symbol">:</a> <a id="4133" href="Library.Bool.html#33" class="Datatype">Bool</a><a id="4137" class="Symbol">)</a> <a id="4139" class="Symbol">-&gt;</a> <a id="4142" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="4152" class="Symbol">(</a><a id="4153" href="Chapter.Logic.Negation.html#4127" class="Bound">x</a> <a id="4155" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="4158" href="Chapter.Logic.Negation.html#4129" class="Bound">y</a><a id="4159" class="Symbol">)</a>
<a id="4161" href="Chapter.Logic.Negation.html#4104" class="Function">Bool-eq-decidable₁</a> <a id="4180" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="4186" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="4192" class="Symbol">=</a> <a id="4194" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="4198" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="4203" href="Chapter.Logic.Negation.html#4104" class="Function">Bool-eq-decidable₁</a> <a id="4222" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="4228" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="4234" class="Symbol">=</a> <a id="4236" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="4239" class="Symbol">λ</a> <a id="4241" class="Symbol">()</a>
<a id="4244" href="Chapter.Logic.Negation.html#4104" class="Function">Bool-eq-decidable₁</a> <a id="4263" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="4269" href="Library.Bool.html#52" class="InductiveConstructor">true</a>  <a id="4275" class="Symbol">=</a> <a id="4277" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="4280" class="Symbol">λ</a> <a id="4282" class="Symbol">()</a>
<a id="4285" href="Chapter.Logic.Negation.html#4104" class="Function">Bool-eq-decidable₁</a> <a id="4304" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="4310" href="Library.Bool.html#57" class="InductiveConstructor">false</a> <a id="4316" class="Symbol">=</a> <a id="4318" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="4322" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
</pre>
Another example of decidabile property is the equality for natural
numbers. In this case, when we compare two numbers of the form `succ
x` and `succ y`, we first decide whether `x` and `y` are equal. If
they are not, then we conclude that `succ x` and `succ y` must be
different (recall that constructors such as `succ` are
injective). If `x` and `y` are equal, then they can be unified and
we can prove `succ x == succ y` by reflexivity.

<pre class="Agda"><a id="Nat-eq-decidable"></a><a id="4776" href="Chapter.Logic.Negation.html#4776" class="Function">Nat-eq-decidable</a> <a id="4793" class="Symbol">:</a> <a id="4795" class="Symbol">∀(</a><a id="4797" href="Chapter.Logic.Negation.html#4797" class="Bound">x</a> <a id="4799" href="Chapter.Logic.Negation.html#4799" class="Bound">y</a> <a id="4801" class="Symbol">:</a> <a id="4803" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="4804" class="Symbol">)</a> <a id="4806" class="Symbol">-&gt;</a> <a id="4809" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="4819" class="Symbol">(</a><a id="4820" href="Chapter.Logic.Negation.html#4797" class="Bound">x</a> <a id="4822" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="4825" href="Chapter.Logic.Negation.html#4799" class="Bound">y</a><a id="4826" class="Symbol">)</a>
<a id="4828" href="Chapter.Logic.Negation.html#4776" class="Function">Nat-eq-decidable</a> <a id="4845" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="4854" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="4863" class="Symbol">=</a> <a id="4865" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="4869" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="4874" href="Chapter.Logic.Negation.html#4776" class="Function">Nat-eq-decidable</a> <a id="4891" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="4900" class="Symbol">(</a><a id="4901" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4906" href="Chapter.Logic.Negation.html#4906" class="Bound">y</a><a id="4907" class="Symbol">)</a> <a id="4909" class="Symbol">=</a> <a id="4911" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="4914" class="Symbol">λ</a> <a id="4916" class="Symbol">()</a>
<a id="4919" href="Chapter.Logic.Negation.html#4776" class="Function">Nat-eq-decidable</a> <a id="4936" class="Symbol">(</a><a id="4937" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4942" href="Chapter.Logic.Negation.html#4942" class="Bound">x</a><a id="4943" class="Symbol">)</a> <a id="4945" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="4954" class="Symbol">=</a> <a id="4956" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="4959" class="Symbol">λ</a> <a id="4961" class="Symbol">()</a>
<a id="4964" href="Chapter.Logic.Negation.html#4776" class="Function">Nat-eq-decidable</a> <a id="4981" class="Symbol">(</a><a id="4982" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4987" href="Chapter.Logic.Negation.html#4987" class="Bound">x</a><a id="4988" class="Symbol">)</a> <a id="4990" class="Symbol">(</a><a id="4991" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4996" href="Chapter.Logic.Negation.html#4996" class="Bound">y</a><a id="4997" class="Symbol">)</a> <a id="4999" class="Keyword">with</a> <a id="5004" href="Chapter.Logic.Negation.html#4776" class="Function">Nat-eq-decidable</a> <a id="5021" href="Chapter.Logic.Negation.html#4987" class="Bound">x</a> <a id="5023" href="Chapter.Logic.Negation.html#4996" class="Bound">y</a>
<a id="5025" class="Symbol">...</a> <a id="5029" class="Symbol">|</a> <a id="5031" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a>  <a id="5035" href="Chapter.Logic.Negation.html#5035" class="Bound">neq</a>  <a id="5040" class="Symbol">=</a> <a id="5042" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="5045" class="Symbol">λ</a> <a id="5047" class="Symbol">{</a> <a id="5049" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5054" class="Symbol">-&gt;</a> <a id="5057" href="Chapter.Logic.Negation.html#5035" class="Bound">neq</a> <a id="5061" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5066" class="Symbol">}</a>
<a id="5068" class="Symbol">...</a> <a id="5072" class="Symbol">|</a> <a id="5074" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="5078" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5083" class="Symbol">=</a> <a id="5085" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="5089" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
</pre>
As a final example we show that the equality of lists is decidable,
provided that the equality between their elements is also decidable.

<pre class="Agda"><a id="List-eq-decidable"></a><a id="5241" href="Chapter.Logic.Negation.html#5241" class="Function">List-eq-decidable</a> <a id="5259" class="Symbol">:</a> <a id="5261" class="Symbol">∀{</a><a id="5263" href="Chapter.Logic.Negation.html#5263" class="Bound">A</a> <a id="5265" class="Symbol">:</a> <a id="5267" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="5270" class="Symbol">}</a> <a id="5272" class="Symbol">-&gt;</a> <a id="5275" class="Symbol">(∀(</a><a id="5278" href="Chapter.Logic.Negation.html#5278" class="Bound">x</a> <a id="5280" href="Chapter.Logic.Negation.html#5280" class="Bound">y</a> <a id="5282" class="Symbol">:</a> <a id="5284" href="Chapter.Logic.Negation.html#5263" class="Bound">A</a><a id="5285" class="Symbol">)</a> <a id="5287" class="Symbol">-&gt;</a> <a id="5290" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="5300" class="Symbol">(</a><a id="5301" href="Chapter.Logic.Negation.html#5278" class="Bound">x</a> <a id="5303" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="5306" href="Chapter.Logic.Negation.html#5280" class="Bound">y</a><a id="5307" class="Symbol">))</a> <a id="5310" class="Symbol">-&gt;</a> <a id="5313" class="Symbol">(</a><a id="5314" href="Chapter.Logic.Negation.html#5314" class="Bound">xs</a> <a id="5317" href="Chapter.Logic.Negation.html#5317" class="Bound">ys</a> <a id="5320" class="Symbol">:</a> <a id="5322" href="Library.List.html#84" class="Datatype">List</a> <a id="5327" href="Chapter.Logic.Negation.html#5263" class="Bound">A</a><a id="5328" class="Symbol">)</a> <a id="5330" class="Symbol">-&gt;</a> <a id="5333" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="5343" class="Symbol">(</a><a id="5344" href="Chapter.Logic.Negation.html#5314" class="Bound">xs</a> <a id="5347" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="5350" href="Chapter.Logic.Negation.html#5317" class="Bound">ys</a><a id="5352" class="Symbol">)</a>
<a id="5354" href="Chapter.Logic.Negation.html#5241" class="Function">List-eq-decidable</a> <a id="5372" href="Chapter.Logic.Negation.html#5372" class="Bound Operator">_==?_</a> <a id="5378" href="Library.List.html#113" class="InductiveConstructor">[]</a>        <a id="5388" href="Library.List.html#113" class="InductiveConstructor">[]</a>        <a id="5398" class="Symbol">=</a> <a id="5400" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="5404" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="5409" href="Chapter.Logic.Negation.html#5241" class="Function">List-eq-decidable</a> <a id="5427" href="Chapter.Logic.Negation.html#5427" class="Bound Operator">_==?_</a> <a id="5433" href="Library.List.html#113" class="InductiveConstructor">[]</a>        <a id="5443" class="Symbol">(</a><a id="5444" href="Chapter.Logic.Negation.html#5444" class="Bound">x</a> <a id="5446" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="5449" href="Chapter.Logic.Negation.html#5449" class="Bound">ys</a><a id="5451" class="Symbol">)</a> <a id="5453" class="Symbol">=</a> <a id="5455" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="5458" class="Symbol">λ</a> <a id="5460" class="Symbol">()</a>
<a id="5463" href="Chapter.Logic.Negation.html#5241" class="Function">List-eq-decidable</a> <a id="5481" href="Chapter.Logic.Negation.html#5481" class="Bound Operator">_==?_</a> <a id="5487" class="Symbol">(</a><a id="5488" href="Chapter.Logic.Negation.html#5488" class="Bound">x</a> <a id="5490" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="5493" href="Chapter.Logic.Negation.html#5493" class="Bound">xs</a><a id="5495" class="Symbol">)</a> <a id="5497" href="Library.List.html#113" class="InductiveConstructor">[]</a>        <a id="5507" class="Symbol">=</a> <a id="5509" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="5512" class="Symbol">λ</a> <a id="5514" class="Symbol">()</a>
<a id="5517" href="Chapter.Logic.Negation.html#5241" class="Function">List-eq-decidable</a> <a id="5535" href="Chapter.Logic.Negation.html#5535" class="Bound Operator">_==?_</a> <a id="5541" class="Symbol">(</a><a id="5542" href="Chapter.Logic.Negation.html#5542" class="Bound">x</a> <a id="5544" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="5547" href="Chapter.Logic.Negation.html#5547" class="Bound">xs</a><a id="5549" class="Symbol">)</a> <a id="5551" class="Symbol">(</a><a id="5552" href="Chapter.Logic.Negation.html#5552" class="Bound">y</a> <a id="5554" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="5557" href="Chapter.Logic.Negation.html#5557" class="Bound">ys</a><a id="5559" class="Symbol">)</a> <a id="5561" class="Keyword">with</a> <a id="5566" href="Chapter.Logic.Negation.html#5542" class="Bound">x</a> <a id="5568" href="Chapter.Logic.Negation.html#5535" class="Bound Operator">==?</a> <a id="5572" href="Chapter.Logic.Negation.html#5552" class="Bound">y</a> <a id="5574" class="Symbol">|</a> <a id="5576" href="Chapter.Logic.Negation.html#5241" class="Function">List-eq-decidable</a> <a id="5594" href="Chapter.Logic.Negation.html#5535" class="Bound Operator">_==?_</a> <a id="5600" href="Chapter.Logic.Negation.html#5547" class="Bound">xs</a> <a id="5603" href="Chapter.Logic.Negation.html#5557" class="Bound">ys</a>
<a id="5606" class="Symbol">...</a> <a id="5610" class="Symbol">|</a> <a id="5612" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a>  <a id="5616" href="Chapter.Logic.Negation.html#5616" class="Bound">neq</a>  <a id="5621" class="Symbol">|</a> <a id="5623" class="Symbol">_</a>        <a id="5632" class="Symbol">=</a> <a id="5634" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="5637" class="Symbol">λ</a> <a id="5639" class="Symbol">{</a> <a id="5641" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5646" class="Symbol">-&gt;</a> <a id="5649" href="Chapter.Logic.Negation.html#5616" class="Bound">neq</a> <a id="5653" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5658" class="Symbol">}</a>
<a id="5660" class="Symbol">...</a> <a id="5664" class="Symbol">|</a> <a id="5666" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="5670" class="Symbol">_</a>    <a id="5675" class="Symbol">|</a> <a id="5677" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a>  <a id="5681" href="Chapter.Logic.Negation.html#5681" class="Bound">neq</a>  <a id="5686" class="Symbol">=</a> <a id="5688" href="Chapter.Logic.Negation.html#4010" class="InductiveConstructor">no</a> <a id="5691" class="Symbol">λ</a> <a id="5693" class="Symbol">{</a> <a id="5695" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5700" class="Symbol">-&gt;</a> <a id="5703" href="Chapter.Logic.Negation.html#5681" class="Bound">neq</a> <a id="5707" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5712" class="Symbol">}</a>
<a id="5714" class="Symbol">...</a> <a id="5718" class="Symbol">|</a> <a id="5720" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="5724" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5729" class="Symbol">|</a> <a id="5731" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="5735" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="5740" class="Symbol">=</a> <a id="5742" href="Chapter.Logic.Negation.html#3988" class="InductiveConstructor">yes</a> <a id="5746" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
</pre>
The case in which we compare two lists of the form `x :: xs` and `y
:: ys` illustrates the use of multiple `with` clauses. In this case,
we have to compare both the heads and the tails of the two
lists. Only if both components are equal can we conclude that the
original lists are equal. Note that each case after the `with`
clauses has as many patterns as the number of `with` clauses.

-->

<h2 id="exercises">Exercises</h2>

<ol>
  <li>Prove the theorem <code class="language-plaintext highlighter-rouge">ntop : ¬ ⊤ -&gt; ⊥</code>.</li>
  <li>Which of the following De Morgan’s laws can be proved?
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>¬ A ∨ ¬ B -&gt; ¬ (A ∧ B)
¬ A ∧ ¬ B -&gt; ¬ (A ∨ B)
¬ (A ∨ B) -&gt; ¬ A ∧ ¬ B
¬ (A ∧ B) -&gt; ¬ A ∨ ¬ B
</code></pre></div>    </div>
  </li>
  <li>Show that the excluded middle implies double negation
elimination, namely prove the theorem <code class="language-plaintext highlighter-rouge">em-dn : (∀{A : Set} -&gt; ¬ A
∨ A) -&gt; ∀{A : Set} -&gt; ¬ ¬ A -&gt; A</code></li>
  <li>Prove the theorem <code class="language-plaintext highlighter-rouge">nndec : ∀{A : Set} -&gt; ¬ ¬ Decidable A</code>. Hint:
one of the De Morgan’s laws helps.</li>
  <li>In classical logic the double negation elimination <code class="language-plaintext highlighter-rouge">¬ ¬ A -&gt; A</code>
is usually assumed to be true. This is not the case in
constructive logic. Show that double negation elimination implies
the excluded middle, namely prove the theorem <code class="language-plaintext highlighter-rouge">dn-em : (∀{A : Set}
-&gt; (¬ ¬ A -&gt; A)) -&gt; ∀{A : Set} -&gt; Decidable A </code>. Hint: use the
solution to the previous exercise.</li>
</ol>
<pre class="Agda solution"><a id="7024" class="Comment">-- EXERCISE 1</a>

<a id="ntop"></a><a id="7039" href="Chapter.Logic.Negation.html#7039" class="Function">ntop</a> <a id="7044" class="Symbol">:</a> <a id="7046" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7048" href="Chapter.Logic.Connectives.html#4718" class="Datatype">⊤</a> <a id="7050" class="Symbol">-&gt;</a> <a id="7053" href="Chapter.Logic.Connectives.html#4889" class="Datatype">⊥</a>
<a id="7055" href="Chapter.Logic.Negation.html#7039" class="Function">ntop</a> <a id="7060" href="Chapter.Logic.Negation.html#7060" class="Bound">p</a> <a id="7062" class="Symbol">=</a> <a id="7064" href="Chapter.Logic.Negation.html#7060" class="Bound">p</a> <a id="7066" href="Chapter.Logic.Connectives.html#4734" class="InductiveConstructor">&lt;&gt;</a>

<a id="7070" class="Comment">-- EXERCISE 2: all laws but the last one can be proved.</a>

<a id="de-morgan-1"></a><a id="7127" href="Chapter.Logic.Negation.html#7127" class="Function">de-morgan-1</a> <a id="7139" class="Symbol">:</a> <a id="7141" class="Symbol">∀{</a><a id="7143" href="Chapter.Logic.Negation.html#7143" class="Bound">A</a> <a id="7145" href="Chapter.Logic.Negation.html#7145" class="Bound">B</a> <a id="7147" class="Symbol">:</a> <a id="7149" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7152" class="Symbol">}</a> <a id="7154" class="Symbol">-&gt;</a> <a id="7157" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7159" href="Chapter.Logic.Negation.html#7143" class="Bound">A</a> <a id="7161" href="Chapter.Logic.Connectives.html#3884" class="Datatype Operator">∨</a> <a id="7163" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7165" href="Chapter.Logic.Negation.html#7145" class="Bound">B</a> <a id="7167" class="Symbol">-&gt;</a> <a id="7170" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7172" class="Symbol">(</a><a id="7173" href="Chapter.Logic.Negation.html#7143" class="Bound">A</a> <a id="7175" href="Chapter.Logic.Connectives.html#1812" class="Datatype Operator">∧</a> <a id="7177" href="Chapter.Logic.Negation.html#7145" class="Bound">B</a><a id="7178" class="Symbol">)</a>
<a id="7180" href="Chapter.Logic.Negation.html#7127" class="Function">de-morgan-1</a> <a id="7192" class="Symbol">=</a> <a id="7194" href="Chapter.Logic.Connectives.html#4239" class="Function">∨-elim</a> <a id="7201" class="Symbol">(</a><a id="7202" href="Chapter.Logic.Negation.html#1817" class="Function">contrapositive</a> <a id="7217" href="Chapter.Logic.Connectives.html#2791" class="Function">fst</a><a id="7220" class="Symbol">)</a> <a id="7222" class="Symbol">(</a><a id="7223" href="Chapter.Logic.Negation.html#1817" class="Function">contrapositive</a> <a id="7238" href="Chapter.Logic.Connectives.html#2841" class="Function">snd</a><a id="7241" class="Symbol">)</a>

<a id="de-morgan-2"></a><a id="7244" href="Chapter.Logic.Negation.html#7244" class="Function">de-morgan-2</a> <a id="7256" class="Symbol">:</a> <a id="7258" class="Symbol">∀{</a><a id="7260" href="Chapter.Logic.Negation.html#7260" class="Bound">A</a> <a id="7262" href="Chapter.Logic.Negation.html#7262" class="Bound">B</a> <a id="7264" class="Symbol">:</a> <a id="7266" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7269" class="Symbol">}</a> <a id="7271" class="Symbol">-&gt;</a> <a id="7274" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7276" href="Chapter.Logic.Negation.html#7260" class="Bound">A</a> <a id="7278" href="Chapter.Logic.Connectives.html#1812" class="Datatype Operator">∧</a> <a id="7280" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7282" href="Chapter.Logic.Negation.html#7262" class="Bound">B</a> <a id="7284" class="Symbol">-&gt;</a> <a id="7287" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7289" class="Symbol">(</a><a id="7290" href="Chapter.Logic.Negation.html#7260" class="Bound">A</a> <a id="7292" href="Chapter.Logic.Connectives.html#3884" class="Datatype Operator">∨</a> <a id="7294" href="Chapter.Logic.Negation.html#7262" class="Bound">B</a><a id="7295" class="Symbol">)</a>
<a id="7297" href="Chapter.Logic.Negation.html#7244" class="Function">de-morgan-2</a> <a id="7309" href="Chapter.Logic.Negation.html#7309" class="Bound">p</a> <a id="7311" class="Symbol">=</a> <a id="7313" href="Chapter.Logic.Connectives.html#4239" class="Function">∨-elim</a> <a id="7320" class="Symbol">(</a><a id="7321" href="Chapter.Logic.Connectives.html#2791" class="Function">fst</a> <a id="7325" href="Chapter.Logic.Negation.html#7309" class="Bound">p</a><a id="7326" class="Symbol">)</a> <a id="7328" class="Symbol">(</a><a id="7329" href="Chapter.Logic.Connectives.html#2841" class="Function">snd</a> <a id="7333" href="Chapter.Logic.Negation.html#7309" class="Bound">p</a><a id="7334" class="Symbol">)</a>

<a id="de-morgan-3"></a><a id="7337" href="Chapter.Logic.Negation.html#7337" class="Function">de-morgan-3</a> <a id="7349" class="Symbol">:</a> <a id="7351" class="Symbol">∀{</a><a id="7353" href="Chapter.Logic.Negation.html#7353" class="Bound">A</a> <a id="7355" href="Chapter.Logic.Negation.html#7355" class="Bound">B</a> <a id="7357" class="Symbol">:</a> <a id="7359" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7362" class="Symbol">}</a> <a id="7364" class="Symbol">-&gt;</a> <a id="7367" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7369" class="Symbol">(</a><a id="7370" href="Chapter.Logic.Negation.html#7353" class="Bound">A</a> <a id="7372" href="Chapter.Logic.Connectives.html#3884" class="Datatype Operator">∨</a> <a id="7374" href="Chapter.Logic.Negation.html#7355" class="Bound">B</a><a id="7375" class="Symbol">)</a> <a id="7377" class="Symbol">-&gt;</a> <a id="7380" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7382" href="Chapter.Logic.Negation.html#7353" class="Bound">A</a> <a id="7384" href="Chapter.Logic.Connectives.html#1812" class="Datatype Operator">∧</a> <a id="7386" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7388" href="Chapter.Logic.Negation.html#7355" class="Bound">B</a>
<a id="7390" href="Chapter.Logic.Negation.html#7337" class="Function">de-morgan-3</a> <a id="7402" href="Chapter.Logic.Negation.html#7402" class="Bound">nab</a> <a id="7406" class="Symbol">=</a> <a id="7408" href="Chapter.Logic.Negation.html#1817" class="Function">contrapositive</a> <a id="7423" href="Chapter.Logic.Connectives.html#3914" class="InductiveConstructor">inl</a> <a id="7427" href="Chapter.Logic.Negation.html#7402" class="Bound">nab</a> <a id="7431" href="Chapter.Logic.Connectives.html#1842" class="InductiveConstructor Operator">,</a> <a id="7433" href="Chapter.Logic.Negation.html#1817" class="Function">contrapositive</a> <a id="7448" href="Chapter.Logic.Connectives.html#3933" class="InductiveConstructor">inr</a> <a id="7452" href="Chapter.Logic.Negation.html#7402" class="Bound">nab</a>

<a id="7457" class="Comment">-- EXERCISE 3</a>

<a id="em-dn"></a><a id="7472" href="Chapter.Logic.Negation.html#7472" class="Function">em-dn</a> <a id="7478" class="Symbol">:</a> <a id="7480" class="Symbol">(∀{</a><a id="7483" href="Chapter.Logic.Negation.html#7483" class="Bound">A</a> <a id="7485" class="Symbol">:</a> <a id="7487" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7490" class="Symbol">}</a> <a id="7492" class="Symbol">-&gt;</a> <a id="7495" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7497" href="Chapter.Logic.Negation.html#7483" class="Bound">A</a> <a id="7499" href="Chapter.Logic.Connectives.html#3884" class="Datatype Operator">∨</a> <a id="7501" href="Chapter.Logic.Negation.html#7483" class="Bound">A</a><a id="7502" class="Symbol">)</a> <a id="7504" class="Symbol">-&gt;</a> <a id="7507" class="Symbol">∀{</a><a id="7509" href="Chapter.Logic.Negation.html#7509" class="Bound">A</a> <a id="7511" class="Symbol">:</a> <a id="7513" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7516" class="Symbol">}</a> <a id="7518" class="Symbol">-&gt;</a> <a id="7521" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7523" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7525" href="Chapter.Logic.Negation.html#7509" class="Bound">A</a> <a id="7527" class="Symbol">-&gt;</a> <a id="7530" href="Chapter.Logic.Negation.html#7509" class="Bound">A</a>
<a id="7532" href="Chapter.Logic.Negation.html#7472" class="Function">em-dn</a> <a id="7538" href="Chapter.Logic.Negation.html#7538" class="Bound">f</a> <a id="7540" class="Symbol">{</a><a id="7541" href="Chapter.Logic.Negation.html#7541" class="Bound">A</a><a id="7542" class="Symbol">}</a> <a id="7544" href="Chapter.Logic.Negation.html#7544" class="Bound">g</a> <a id="7546" class="Keyword">with</a> <a id="7551" href="Chapter.Logic.Negation.html#7538" class="Bound">f</a> <a id="7553" class="Symbol">{</a><a id="7554" href="Chapter.Logic.Negation.html#7541" class="Bound">A</a><a id="7555" class="Symbol">}</a>
<a id="7557" class="Symbol">...</a> <a id="7561" class="Symbol">|</a> <a id="7563" href="Chapter.Logic.Connectives.html#3914" class="InductiveConstructor">inl</a> <a id="7567" href="Chapter.Logic.Negation.html#7567" class="Bound">x</a> <a id="7569" class="Symbol">=</a> <a id="7571" href="Chapter.Logic.Connectives.html#5178" class="Function">ex-falso</a> <a id="7580" class="Symbol">(</a><a id="7581" class="Bound">g</a> <a id="7583" href="Chapter.Logic.Negation.html#7567" class="Bound">x</a><a id="7584" class="Symbol">)</a>
<a id="7586" class="Symbol">...</a> <a id="7590" class="Symbol">|</a> <a id="7592" href="Chapter.Logic.Connectives.html#3933" class="InductiveConstructor">inr</a> <a id="7596" href="Chapter.Logic.Negation.html#7596" class="Bound">x</a> <a id="7598" class="Symbol">=</a> <a id="7600" href="Chapter.Logic.Negation.html#7596" class="Bound">x</a>

<a id="7603" class="Comment">-- EXERCISE 4</a>

<a id="nndec"></a><a id="7618" href="Chapter.Logic.Negation.html#7618" class="Function">nndec</a> <a id="7624" class="Symbol">:</a> <a id="7626" class="Symbol">∀{</a><a id="7628" href="Chapter.Logic.Negation.html#7628" class="Bound">A</a> <a id="7630" class="Symbol">:</a> <a id="7632" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7635" class="Symbol">}</a> <a id="7637" class="Symbol">-&gt;</a> <a id="7640" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7642" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7644" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="7654" href="Chapter.Logic.Negation.html#7628" class="Bound">A</a>
<a id="7656" href="Chapter.Logic.Negation.html#7618" class="Function">nndec</a> <a id="7662" href="Chapter.Logic.Negation.html#7662" class="Bound">p</a> <a id="7664" class="Keyword">with</a> <a id="7669" href="Chapter.Logic.Negation.html#7337" class="Function">de-morgan-3</a> <a id="7681" href="Chapter.Logic.Negation.html#7662" class="Bound">p</a>
<a id="7683" class="Symbol">...</a> <a id="7687" class="Symbol">|</a> <a id="7689" href="Chapter.Logic.Negation.html#7689" class="Bound">nna</a> <a id="7693" href="Chapter.Logic.Connectives.html#1842" class="InductiveConstructor Operator">,</a> <a id="7695" href="Chapter.Logic.Negation.html#7695" class="Bound">na</a> <a id="7698" class="Symbol">=</a> <a id="7700" href="Chapter.Logic.Negation.html#7689" class="Bound">nna</a> <a id="7704" href="Chapter.Logic.Negation.html#7695" class="Bound">na</a>

<a id="7708" class="Comment">-- EXERCISE 5</a>

<a id="dn-em"></a><a id="7723" href="Chapter.Logic.Negation.html#7723" class="Function">dn-em</a> <a id="7729" class="Symbol">:</a> <a id="7731" class="Symbol">(∀{</a><a id="7734" href="Chapter.Logic.Negation.html#7734" class="Bound">A</a> <a id="7736" class="Symbol">:</a> <a id="7738" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7741" class="Symbol">}</a> <a id="7743" class="Symbol">-&gt;</a> <a id="7746" class="Symbol">(</a><a id="7747" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7749" href="Chapter.Logic.Negation.html#603" class="Function Operator">¬</a> <a id="7751" href="Chapter.Logic.Negation.html#7734" class="Bound">A</a> <a id="7753" class="Symbol">-&gt;</a> <a id="7756" href="Chapter.Logic.Negation.html#7734" class="Bound">A</a><a id="7757" class="Symbol">))</a> <a id="7760" class="Symbol">-&gt;</a> <a id="7763" class="Symbol">∀{</a><a id="7765" href="Chapter.Logic.Negation.html#7765" class="Bound">B</a> <a id="7767" class="Symbol">:</a> <a id="7769" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="7772" class="Symbol">}</a> <a id="7774" class="Symbol">-&gt;</a> <a id="7777" href="Chapter.Logic.Negation.html#3081" class="Function">Decidable</a> <a id="7787" href="Chapter.Logic.Negation.html#7765" class="Bound">B</a>
<a id="7789" href="Chapter.Logic.Negation.html#7723" class="Function">dn-em</a> <a id="7795" href="Chapter.Logic.Negation.html#7795" class="Bound">f</a> <a id="7797" class="Symbol">=</a> <a id="7799" href="Chapter.Logic.Negation.html#7795" class="Bound">f</a> <a id="7801" href="Chapter.Logic.Negation.html#7618" class="Function">nndec</a>
</pre>

  </div>
  <ul class="menu">
  <li>
    <a href="Chapter.Logic.Connectives.html">‹ Logical connectives and constants</a></li>
  <li>
    <a href="Chapter.Logic.Existential.html">Existential quantification ›</a></li>
</ul>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>
  <div class="wrapper">
    <!-- <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"> -->
    <!--   <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"/> -->
    <!-- </a> -->
    2022-2023
    <a href="https://boystrange.github.io">Luca Padovani</a>
    and <a href="http://www.di.unito.it/~deligu/">Ugo de'Liguoro</a>.
    Page generated on 20 Sep 2023.
  </div>
</footer>
</body>

</html>
