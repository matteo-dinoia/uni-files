<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Defining predicates | Introduction to Program Verification in Agda</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Defining predicates" />
<meta property="og:locale" content="en_US" />
<meta property="og:site_name" content="Introduction to Program Verification in Agda" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Defining predicates" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Defining predicates","url":"/pages/Chapter.Logic.Predicates.html"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/Agda.css">
  <script src="../assets/js/mathjax.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="../assets/js/codereveal.js"></script>
  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Introduction to Program Verification in Agda" /><!-- <script src="/assets/js/clipboard.min.js"></script> -->
  <!-- <script src="/assets/js/codeselect.js"></script> -->
</head>
<body>

<header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="../index.html">Introduction to Program Verification in Agda</a>
    

    <nav class="site-nav">
      <a href="https://agda.readthedocs.io/en/latest/">AGDA DOCS</a>
    </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <ul class="menu">
  <li>
    <a href="Chapter.Logic.Existential.html">‹ Existential quantification</a></li>
  <li>
    <a href="Chapter.Logic.Equality.html">Equality ›</a></li>
</ul>
  <header class="post-header">
    <h1 class="post-title">Defining predicates</h1>
  </header>

  <div class="post-content">
    <pre class="Agda"><a id="104" class="Keyword">module</a> <a id="111" href="Chapter.Logic.Predicates.html" class="Module">Chapter.Logic.Predicates</a> <a id="136" class="Keyword">where</a>
</pre>
<p>In this chapter we study and compare several techniques with which
it is possible to define <em>predicates</em> in Agda.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="278" class="Keyword">open</a> <a id="283" class="Keyword">import</a> <a id="290" href="Library.Fun.html" class="Module">Library.Fun</a>
<a id="302" class="Keyword">open</a> <a id="307" class="Keyword">import</a> <a id="314" href="Library.Bool.html" class="Module">Library.Bool</a>
<a id="327" class="Keyword">open</a> <a id="332" class="Keyword">import</a> <a id="339" href="Library.Nat.html" class="Module">Library.Nat</a>
<a id="351" class="Keyword">open</a> <a id="356" class="Keyword">import</a> <a id="363" href="Library.Logic.html" class="Module">Library.Logic</a>
<a id="377" class="Keyword">open</a> <a id="382" class="Keyword">import</a> <a id="389" href="Library.Logic.Laws.html" class="Module">Library.Logic.Laws</a>
<a id="408" class="Keyword">open</a> <a id="413" class="Keyword">import</a> <a id="420" href="Library.Equality.html" class="Module">Library.Equality</a>
</pre>
<h2 id="the-half-of-a-natural-number">The half of a natural number</h2>

<p>Consider the following function which computes the (truncated) half
of a natural number:</p>

<pre class="Agda"><a id="half"></a><a id="569" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="574" class="Symbol">:</a> <a id="576" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="578" class="Symbol">-&gt;</a> <a id="581" href="Library.Nat.html#32" class="Datatype">ℕ</a>
<a id="583" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="588" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="604" class="Symbol">=</a> <a id="606" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>
<a id="611" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="616" class="Symbol">(</a><a id="617" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="622" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="626" class="Symbol">)</a>     <a id="632" class="Symbol">=</a> <a id="634" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>
<a id="639" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="644" class="Symbol">(</a><a id="645" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="650" class="Symbol">(</a><a id="651" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="656" href="Chapter.Logic.Predicates.html#656" class="Bound">x</a><a id="657" class="Symbol">))</a> <a id="660" class="Symbol">=</a> <a id="662" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="667" class="Symbol">(</a><a id="668" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="673" href="Chapter.Logic.Predicates.html#656" class="Bound">x</a><a id="674" class="Symbol">)</a>
</pre>
<p>We would like to prove a theorem asserting that, by doubling the
half of an even natural number <code class="language-plaintext highlighter-rouge">x</code>, we obtain the original number
<code class="language-plaintext highlighter-rouge">x</code>. In order to do so, we have to teach Agda what it means for a
natural number to be even. As we will see, there are several ways of
doing this. For each way, we will show how to prove the desired
result discussing pros and cons of the approach.</p>

<h2 id="being-even-programmatically">Being even, programmatically</h2>

<p>The first, and possibly most obvious, way of defining “evenness” is
by means of a recursive function that returns either <code class="language-plaintext highlighter-rouge">true</code> or
<code class="language-plaintext highlighter-rouge">false</code>. We call this the “programmer’s” way of defining evenness,
since it is the approach that any (functional) programmer would
choose in the first place.</p>

<pre class="Agda"><a id="Even-p"></a><a id="1388" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="1395" class="Symbol">:</a> <a id="1397" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="1399" class="Symbol">-&gt;</a> <a id="1402" href="Library.Bool.html#33" class="Datatype">Bool</a>
<a id="1407" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="1414" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="1430" class="Symbol">=</a> <a id="1432" href="Library.Bool.html#52" class="InductiveConstructor">true</a>
<a id="1437" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="1444" class="Symbol">(</a><a id="1445" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="1450" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="1454" class="Symbol">)</a>     <a id="1460" class="Symbol">=</a> <a id="1462" href="Library.Bool.html#57" class="InductiveConstructor">false</a>
<a id="1468" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="1475" class="Symbol">(</a><a id="1476" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="1481" class="Symbol">(</a><a id="1482" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="1487" href="Chapter.Logic.Predicates.html#1487" class="Bound">x</a><a id="1488" class="Symbol">))</a> <a id="1491" class="Symbol">=</a> <a id="1493" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="1500" href="Chapter.Logic.Predicates.html#1487" class="Bound">x</a>
</pre>
<p>Notice that <code class="language-plaintext highlighter-rouge">Even-p x</code> is a <em>term</em> of type <code class="language-plaintext highlighter-rouge">Bool</code>. So, in order to
use <code class="language-plaintext highlighter-rouge">Even-p</code> as a predicate, we have to compare the result of
<code class="language-plaintext highlighter-rouge">Even-p x</code> to <code class="language-plaintext highlighter-rouge">true</code> using equality. We can thus formulate our
theorem as follows.</p>

<pre class="Agda"><a id="theorem-p"></a><a id="1724" href="Chapter.Logic.Predicates.html#1724" class="Function">theorem-p</a> <a id="1734" class="Symbol">:</a> <a id="1736" class="Symbol">∀{</a><a id="1738" href="Chapter.Logic.Predicates.html#1738" class="Bound">x</a> <a id="1740" class="Symbol">:</a> <a id="1742" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="1743" class="Symbol">}</a> <a id="1745" class="Symbol">(</a><a id="1746" href="Chapter.Logic.Predicates.html#1746" class="Bound">ev</a> <a id="1749" class="Symbol">:</a> <a id="1751" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="1758" href="Chapter.Logic.Predicates.html#1738" class="Bound">x</a> <a id="1760" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="1763" href="Library.Bool.html#52" class="InductiveConstructor">true</a><a id="1767" class="Symbol">)</a> <a id="1769" class="Symbol">-&gt;</a> <a id="1772" href="Chapter.Logic.Predicates.html#1738" class="Bound">x</a> <a id="1774" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="1777" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="1782" href="Chapter.Logic.Predicates.html#1738" class="Bound">x</a> <a id="1784" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="1786" class="Number">2</a>
<a id="1788" href="Chapter.Logic.Predicates.html#1724" class="Function">theorem-p</a> <a id="1798" class="Symbol">{</a><a id="1799" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="1803" class="Symbol">}</a>          <a id="1814" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="1819" class="Symbol">=</a> <a id="1821" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="1826" href="Chapter.Logic.Predicates.html#1724" class="Function">theorem-p</a> <a id="1836" class="Symbol">{</a><a id="1837" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="1842" class="Symbol">(</a><a id="1843" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="1848" href="Chapter.Logic.Predicates.html#1848" class="Bound">x</a><a id="1849" class="Symbol">)}</a> <a id="1852" href="Chapter.Logic.Predicates.html#1852" class="Bound">ev</a>   <a id="1857" class="Symbol">=</a> <a id="1859" href="Library.Equality.html#373" class="Function">cong</a> <a id="1864" class="Symbol">(</a><a id="1865" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="1870" href="Library.Fun.html#112" class="Function Operator">∘</a> <a id="1872" href="Library.Nat.html#59" class="InductiveConstructor">succ</a><a id="1876" class="Symbol">)</a> <a id="1878" class="Symbol">(</a><a id="1879" href="Chapter.Logic.Predicates.html#1724" class="Function">theorem-p</a> <a id="1889" href="Chapter.Logic.Predicates.html#1852" class="Bound">ev</a><a id="1891" class="Symbol">)</a>
</pre>
<p>We are forced to perform case analysis on the (implicit) argument
<code class="language-plaintext highlighter-rouge">x</code>, since the proof <code class="language-plaintext highlighter-rouge">ev</code> that <code class="language-plaintext highlighter-rouge">x</code> is an even number (which must
have the form <code class="language-plaintext highlighter-rouge">refl</code> for this is the only normal proof of an
equality proof) bears no structure that helps us proving the
theorem. Interestingly, Agda does not propose an equation for the
case <code class="language-plaintext highlighter-rouge">succ zero</code>. This happens because <code class="language-plaintext highlighter-rouge">Even-p 1</code> yields <code class="language-plaintext highlighter-rouge">false</code>,
which is certainly different from <code class="language-plaintext highlighter-rouge">true</code>, so Agda realizes that this
case is impossible.</p>

<h2 id="being-even-mathematically">Being even, mathematically</h2>

<p>A mathematician asked to define evenness could possibly say that a
natural number <code class="language-plaintext highlighter-rouge">x</code> is even if it is the double of another natural
number <code class="language-plaintext highlighter-rouge">y</code>. Being the double of some natural number <code class="language-plaintext highlighter-rouge">y</code> is a
property that we can specify in Agda using an existential type. So,
we can define this notion of evenness as follows.</p>

<pre class="Agda"><a id="Even-m"></a><a id="2721" href="Chapter.Logic.Predicates.html#2721" class="Function">Even-m</a> <a id="2728" class="Symbol">:</a> <a id="2730" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="2732" class="Symbol">-&gt;</a> <a id="2735" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2739" href="Chapter.Logic.Predicates.html#2721" class="Function">Even-m</a> <a id="2746" href="Chapter.Logic.Predicates.html#2746" class="Bound">x</a> <a id="2748" class="Symbol">=</a> <a id="2750" href="Library.Logic.html#632" class="Function">∃[</a> <a id="2753" href="Chapter.Logic.Predicates.html#2753" class="Bound">y</a> <a id="2755" href="Library.Logic.html#632" class="Function">]</a> <a id="2757" href="Chapter.Logic.Predicates.html#2746" class="Bound">x</a> <a id="2759" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="2762" href="Chapter.Logic.Predicates.html#2753" class="Bound">y</a> <a id="2764" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="2766" class="Number">2</a>
</pre>
<p>Unlike <code class="language-plaintext highlighter-rouge">Even-p</code>, which returns a <em>term</em> (of type <code class="language-plaintext highlighter-rouge">Bool</code>), <code class="language-plaintext highlighter-rouge">Even-m</code>
returns a <em>type</em> (of type <code class="language-plaintext highlighter-rouge">Set</code>). This type is inhabited by pairs of
the form <code class="language-plaintext highlighter-rouge">(y , p)</code> where <code class="language-plaintext highlighter-rouge">y</code> is some natural number and <code class="language-plaintext highlighter-rouge">p</code> is a
proof that <code class="language-plaintext highlighter-rouge">x</code> is the double of <code class="language-plaintext highlighter-rouge">y</code>. For example, we can prove that
<code class="language-plaintext highlighter-rouge">4</code> is even as follows.</p>

<pre class="Agda"><a id="3071" href="Chapter.Logic.Predicates.html#3071" class="Function">_</a> <a id="3073" class="Symbol">:</a> <a id="3075" href="Chapter.Logic.Predicates.html#2721" class="Function">Even-m</a> <a id="3082" class="Number">4</a>
<a id="3084" class="Symbol">_</a> <a id="3086" class="Symbol">=</a> <a id="3088" class="Number">2</a> <a id="3090" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="3092" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
</pre>
<p>Analogously we can show that <code class="language-plaintext highlighter-rouge">1</code> is <em>not</em> even by proving a
contradiction if we assume that it is even.</p>

<pre class="Agda"><a id="3211" href="Chapter.Logic.Predicates.html#3211" class="Function">_</a> <a id="3213" class="Symbol">:</a> <a id="3215" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="3217" href="Chapter.Logic.Predicates.html#2721" class="Function">Even-m</a> <a id="3224" class="Number">1</a>
<a id="3226" class="Symbol">_</a> <a id="3228" class="Symbol">=</a> <a id="3230" class="Symbol">λ</a> <a id="3232" class="Symbol">{</a> <a id="3234" class="Symbol">(</a><a id="3235" href="Library.Nat.html#48" class="InductiveConstructor">zero</a> <a id="3240" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="3242" class="Symbol">())</a> <a id="3246" class="Symbol">;</a> <a id="3248" class="Symbol">(</a><a id="3249" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="3254" class="Symbol">_</a> <a id="3256" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="3258" class="Symbol">())</a> <a id="3262" class="Symbol">}</a>
</pre>
<p>When proving that doubling the half of an even number <code class="language-plaintext highlighter-rouge">x</code> yields
<code class="language-plaintext highlighter-rouge">x</code>, we can perform case analysis on the proof that <code class="language-plaintext highlighter-rouge">x</code> is even
obtaining some witness <code class="language-plaintext highlighter-rouge">y</code> whose double is known to be <code class="language-plaintext highlighter-rouge">x</code>. We can
conclude if we are able to show that halving a doubled number <code class="language-plaintext highlighter-rouge">y</code>
yields <code class="language-plaintext highlighter-rouge">y</code>. For this, we need to prove an auxiliary lemma, which we
locally define within <code class="language-plaintext highlighter-rouge">theorem-m</code> after the keyword <code class="language-plaintext highlighter-rouge">where</code>.</p>

<pre class="Agda"><a id="theorem-m"></a><a id="3665" href="Chapter.Logic.Predicates.html#3665" class="Function">theorem-m</a> <a id="3675" class="Symbol">:</a> <a id="3677" class="Symbol">∀{</a><a id="3679" href="Chapter.Logic.Predicates.html#3679" class="Bound">x</a> <a id="3681" class="Symbol">:</a> <a id="3683" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="3684" class="Symbol">}</a> <a id="3686" class="Symbol">(</a><a id="3687" href="Chapter.Logic.Predicates.html#3687" class="Bound">ev</a> <a id="3690" class="Symbol">:</a> <a id="3692" href="Chapter.Logic.Predicates.html#2721" class="Function">Even-m</a> <a id="3699" href="Chapter.Logic.Predicates.html#3679" class="Bound">x</a><a id="3700" class="Symbol">)</a> <a id="3702" class="Symbol">-&gt;</a> <a id="3705" href="Chapter.Logic.Predicates.html#3679" class="Bound">x</a> <a id="3707" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="3710" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="3715" href="Chapter.Logic.Predicates.html#3679" class="Bound">x</a> <a id="3717" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="3719" class="Number">2</a>
<a id="3721" href="Chapter.Logic.Predicates.html#3665" class="Function">theorem-m</a> <a id="3731" class="Symbol">(</a><a id="3732" href="Chapter.Logic.Predicates.html#3732" class="Bound">y</a> <a id="3734" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="3736" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="3740" class="Symbol">)</a> <a id="3742" class="Symbol">=</a> <a id="3744" href="Library.Equality.html#373" class="Function">cong</a> <a id="3749" class="Symbol">(</a><a id="3750" href="Library.Nat.html#293" class="Function Operator">_*</a> <a id="3753" class="Number">2</a><a id="3754" class="Symbol">)</a> <a id="3756" class="Symbol">(</a><a id="3757" href="Chapter.Logic.Predicates.html#3776" class="Function">lem</a> <a id="3761" href="Chapter.Logic.Predicates.html#3732" class="Bound">y</a><a id="3762" class="Symbol">)</a>
  <a id="3766" class="Keyword">where</a>
    <a id="3776" href="Chapter.Logic.Predicates.html#3776" class="Function">lem</a> <a id="3780" class="Symbol">:</a> <a id="3782" class="Symbol">(</a><a id="3783" href="Chapter.Logic.Predicates.html#3783" class="Bound">x</a> <a id="3785" class="Symbol">:</a> <a id="3787" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="3788" class="Symbol">)</a> <a id="3790" class="Symbol">-&gt;</a> <a id="3793" href="Chapter.Logic.Predicates.html#3783" class="Bound">x</a> <a id="3795" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="3798" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="3803" class="Symbol">(</a><a id="3804" href="Chapter.Logic.Predicates.html#3783" class="Bound">x</a> <a id="3806" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="3808" class="Number">2</a><a id="3809" class="Symbol">)</a>
    <a id="3815" href="Chapter.Logic.Predicates.html#3776" class="Function">lem</a> <a id="3819" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="3828" class="Symbol">=</a> <a id="3830" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
    <a id="3839" href="Chapter.Logic.Predicates.html#3776" class="Function">lem</a> <a id="3843" class="Symbol">(</a><a id="3844" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="3849" href="Chapter.Logic.Predicates.html#3849" class="Bound">x</a><a id="3850" class="Symbol">)</a> <a id="3852" class="Symbol">=</a> <a id="3854" href="Library.Equality.html#373" class="Function">cong</a> <a id="3859" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="3864" class="Symbol">(</a><a id="3865" href="Chapter.Logic.Predicates.html#3776" class="Function">lem</a> <a id="3869" href="Chapter.Logic.Predicates.html#3849" class="Bound">x</a><a id="3870" class="Symbol">)</a>
</pre>
<h2 id="type-level-computations">Type-level computations</h2>

<p>In the previous approach we have defined a function <code class="language-plaintext highlighter-rouge">Even-m</code> that,
applied to a natural number <code class="language-plaintext highlighter-rouge">x</code>, yields the type of proofs that <code class="language-plaintext highlighter-rouge">x</code>
is even. We can apply the same principle to write an alternative
version of <code class="language-plaintext highlighter-rouge">Even-p</code> in which the result is a type instead of a
boolean value. In this case, the returned type is <code class="language-plaintext highlighter-rouge">⊤</code> when we
realize that <code class="language-plaintext highlighter-rouge">x</code> is even and <code class="language-plaintext highlighter-rouge">⊥</code> otherwise. This approach is
sometimes referred to as making use of <em>type-level computations</em>
because it computes a type (<code class="language-plaintext highlighter-rouge">Even-r x</code>) from a term <code class="language-plaintext highlighter-rouge">x</code> (technically
speaking, also <code class="language-plaintext highlighter-rouge">Even-m</code> is defined in this way).</p>

<pre class="Agda"><a id="Even-r"></a><a id="4479" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="4486" class="Symbol">:</a> <a id="4488" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="4490" class="Symbol">-&gt;</a> <a id="4493" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="4497" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="4504" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="4520" class="Symbol">=</a> <a id="4522" href="Library.Logic.html#178" class="Datatype">⊤</a>
<a id="4524" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="4531" class="Symbol">(</a><a id="4532" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4537" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="4541" class="Symbol">)</a>     <a id="4547" class="Symbol">=</a> <a id="4549" href="Library.Logic.html#150" class="Datatype">⊥</a>
<a id="4551" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="4558" class="Symbol">(</a><a id="4559" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4564" class="Symbol">(</a><a id="4565" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4570" href="Chapter.Logic.Predicates.html#4570" class="Bound">x</a><a id="4571" class="Symbol">))</a> <a id="4574" class="Symbol">=</a> <a id="4576" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="4583" href="Chapter.Logic.Predicates.html#4570" class="Bound">x</a>
</pre>
<p>Compared to <code class="language-plaintext highlighter-rouge">Even-p</code>, the advantage of <code class="language-plaintext highlighter-rouge">Even-r</code> is that it yields a
type, so it is not necessary to use equality to turn <code class="language-plaintext highlighter-rouge">Even-r x</code> into
a type. However, just like when using <code class="language-plaintext highlighter-rouge">Even-p</code>, the proof of <code class="language-plaintext highlighter-rouge">Even-r
x</code> is simply <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>, so inspecting the proof of <code class="language-plaintext highlighter-rouge">Even-r x</code> does not
reveal anything useful about <code class="language-plaintext highlighter-rouge">x</code> and we are forced to perform case
analysis on <code class="language-plaintext highlighter-rouge">x</code> to complete our theorem.</p>

<pre class="Agda"><a id="theorem-r"></a><a id="4975" href="Chapter.Logic.Predicates.html#4975" class="Function">theorem-r</a> <a id="4985" class="Symbol">:</a> <a id="4987" class="Symbol">∀{</a><a id="4989" href="Chapter.Logic.Predicates.html#4989" class="Bound">x</a> <a id="4991" class="Symbol">:</a> <a id="4993" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="4994" class="Symbol">}</a> <a id="4996" class="Symbol">(</a><a id="4997" href="Chapter.Logic.Predicates.html#4997" class="Bound">ev</a> <a id="5000" class="Symbol">:</a> <a id="5002" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="5009" href="Chapter.Logic.Predicates.html#4989" class="Bound">x</a><a id="5010" class="Symbol">)</a> <a id="5012" class="Symbol">-&gt;</a> <a id="5015" href="Chapter.Logic.Predicates.html#4989" class="Bound">x</a> <a id="5017" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="5020" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="5025" href="Chapter.Logic.Predicates.html#4989" class="Bound">x</a> <a id="5027" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="5029" class="Number">2</a>
<a id="5031" href="Chapter.Logic.Predicates.html#4975" class="Function">theorem-r</a> <a id="5041" class="Symbol">{</a><a id="5042" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="5046" class="Symbol">}</a>          <a id="5057" href="Library.Logic.html#194" class="InductiveConstructor">&lt;&gt;</a> <a id="5060" class="Symbol">=</a> <a id="5062" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="5067" href="Chapter.Logic.Predicates.html#4975" class="Function">theorem-r</a> <a id="5077" class="Symbol">{</a><a id="5078" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="5083" class="Symbol">(</a><a id="5084" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="5089" href="Chapter.Logic.Predicates.html#5089" class="Bound">x</a><a id="5090" class="Symbol">)}</a> <a id="5093" href="Chapter.Logic.Predicates.html#5093" class="Bound">ev</a> <a id="5096" class="Symbol">=</a> <a id="5098" href="Library.Equality.html#373" class="Function">cong</a> <a id="5103" class="Symbol">(</a><a id="5104" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="5109" href="Library.Fun.html#112" class="Function Operator">∘</a> <a id="5111" href="Library.Nat.html#59" class="InductiveConstructor">succ</a><a id="5115" class="Symbol">)</a> <a id="5117" class="Symbol">(</a><a id="5118" href="Chapter.Logic.Predicates.html#4975" class="Function">theorem-r</a> <a id="5128" href="Chapter.Logic.Predicates.html#5093" class="Bound">ev</a><a id="5130" class="Symbol">)</a>
</pre>
<p>Also in this approach Agda does not propose a case for <code class="language-plaintext highlighter-rouge">succ zero</code>
when we perform case analysis on <code class="language-plaintext highlighter-rouge">x</code>. The reason is that, in this
case, <code class="language-plaintext highlighter-rouge">ev</code> has type <code class="language-plaintext highlighter-rouge">Even-r 1</code> which is <code class="language-plaintext highlighter-rouge">⊥</code>. Agda figures that no
such term exists (<code class="language-plaintext highlighter-rouge">⊥</code> is not inhabited by any term).</p>

<h2 id="being-even-as-an-inference-system">Being even as an inference system</h2>

<p>The final point of view we consider is motivated by the observation
that the set of <em>even natural numbers</em> is the smallest set $X$ such
that:</p>

<ul>
  <li>$0 \in X$, and</li>
  <li>if $x \in X$, then $2 + x \in X$ as well.</li>
</ul>

<p>In other words, we can characterize the whole set of even numbers as
those satisfying the predicate <code class="language-plaintext highlighter-rouge">Even x</code>, where <code class="language-plaintext highlighter-rouge">Even</code> is inductively
defined by the following inference rules.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                     Even x
[even-zero] ------    [even-succ] ------------
            Even 0                Even (2 + x)
</code></pre></div></div>

<p>The axiom <code class="language-plaintext highlighter-rouge">[even-zero]</code> asserts that <code class="language-plaintext highlighter-rouge">0</code> is an even number. The rule
<code class="language-plaintext highlighter-rouge">[even-succ]</code> asserts that <code class="language-plaintext highlighter-rouge">2 + x</code> is even whenever <code class="language-plaintext highlighter-rouge">x</code> is. We can
define this inference system as an inductive data type such that</p>

<ul>
  <li>the name of the data type (<code class="language-plaintext highlighter-rouge">Even-i</code>) corresponds to the name of
the predicate (<code class="language-plaintext highlighter-rouge">Even</code>) we are defining;</li>
  <li>the constructors of the data type correspond to axioms/rules in
the inference system defining the predicate;</li>
  <li>terms of the data type correspond to derivations in this inference system.</li>
</ul>

<p>Note that the evenness predicate <code class="language-plaintext highlighter-rouge">Even-i x</code> we are defining in this
way depends on the natural number <code class="language-plaintext highlighter-rouge">x</code> that is claimed to be even. We
cannot express this dependency merely using a parameter of the data
type, since parameters are supposed to be the same across the whole
data type definition whereas the value of <code class="language-plaintext highlighter-rouge">x</code> varies (e.g., it is
<code class="language-plaintext highlighter-rouge">0</code> in <code class="language-plaintext highlighter-rouge">[even-zero]</code> and it is <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">2 + x</code> in
<code class="language-plaintext highlighter-rouge">[even-succ]</code>). For this reason, we define an <strong>indexed data type</strong>
(also known as <strong>inductive family</strong>), which differs from a plain (or
parametric) data type as it contains one or more <strong>indexes</strong>. In our
case, a single index of type <code class="language-plaintext highlighter-rouge">ℕ</code> suffices.</p>

<pre class="Agda"><a id="7109" class="Keyword">data</a> <a id="Even-i"></a><a id="7114" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="7121" class="Symbol">:</a> <a id="7123" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="7125" class="Symbol">-&gt;</a> <a id="7128" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="7132" class="Keyword">where</a>
  <a id="Even-i.even-zero"></a><a id="7140" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a> <a id="7150" class="Symbol">:</a> <a id="7152" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="7159" class="Number">0</a>
  <a id="Even-i.even-succ"></a><a id="7163" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="7173" class="Symbol">:</a> <a id="7175" class="Symbol">{</a><a id="7176" href="Chapter.Logic.Predicates.html#7176" class="Bound">x</a> <a id="7178" class="Symbol">:</a> <a id="7180" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="7181" class="Symbol">}</a> <a id="7183" class="Symbol">-&gt;</a> <a id="7186" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="7193" href="Chapter.Logic.Predicates.html#7176" class="Bound">x</a> <a id="7195" class="Symbol">-&gt;</a> <a id="7198" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="7205" class="Symbol">(</a><a id="7206" class="Number">2</a> <a id="7208" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="7210" href="Chapter.Logic.Predicates.html#7176" class="Bound">x</a><a id="7211" class="Symbol">)</a>
</pre>
<p>The type of <code class="language-plaintext highlighter-rouge">Even-i</code> is <code class="language-plaintext highlighter-rouge">ℕ -&gt; Set</code> and not just <code class="language-plaintext highlighter-rouge">Set</code>, namely
<code class="language-plaintext highlighter-rouge">Even-i</code> is a function that, applied to some natural number <code class="language-plaintext highlighter-rouge">x</code>,
yields a type. The <code class="language-plaintext highlighter-rouge">x</code> is the index of <code class="language-plaintext highlighter-rouge">Even-i</code>. There are two ways
of building terms of type <code class="language-plaintext highlighter-rouge">Even-i x</code>. One is through the constructor
<code class="language-plaintext highlighter-rouge">even-zero</code>. In this case <code class="language-plaintext highlighter-rouge">x</code> must be <code class="language-plaintext highlighter-rouge">0</code>. The other is through the
constructor <code class="language-plaintext highlighter-rouge">even-succ</code> applied to a term of type <code class="language-plaintext highlighter-rouge">Even-i x</code>, which
yields a term of type <code class="language-plaintext highlighter-rouge">Even-i (2 + x)</code>.</p>

<p>As an example, we can prove that <code class="language-plaintext highlighter-rouge">4</code> is even and that <code class="language-plaintext highlighter-rouge">1</code> is not as
follows.</p>

<pre class="Agda"><a id="7741" href="Chapter.Logic.Predicates.html#7741" class="Function">_</a> <a id="7743" class="Symbol">:</a> <a id="7745" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="7752" class="Number">4</a>
<a id="7754" class="Symbol">_</a> <a id="7756" class="Symbol">=</a> <a id="7758" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="7768" class="Symbol">(</a><a id="7769" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="7779" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a><a id="7788" class="Symbol">)</a>

<a id="7791" href="Chapter.Logic.Predicates.html#7791" class="Function">_</a> <a id="7793" class="Symbol">:</a> <a id="7795" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="7797" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="7804" class="Number">1</a>
<a id="7806" class="Symbol">_</a> <a id="7808" class="Symbol">=</a> <a id="7810" class="Symbol">λ</a> <a id="7812" class="Symbol">()</a>
</pre>
<p>When we prove our theorem using <code class="language-plaintext highlighter-rouge">Even-i</code> we can perform a case
analysis directly on <code class="language-plaintext highlighter-rouge">Even-i x</code>, which contains all the structure we
need.</p>

<pre class="Agda"><a id="theorem-i"></a><a id="7963" href="Chapter.Logic.Predicates.html#7963" class="Function">theorem-i</a> <a id="7973" class="Symbol">:</a> <a id="7975" class="Symbol">∀{</a><a id="7977" href="Chapter.Logic.Predicates.html#7977" class="Bound">x</a> <a id="7979" class="Symbol">:</a> <a id="7981" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="7982" class="Symbol">}</a> <a id="7984" class="Symbol">(</a><a id="7985" href="Chapter.Logic.Predicates.html#7985" class="Bound">ev</a> <a id="7988" class="Symbol">:</a> <a id="7990" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="7997" href="Chapter.Logic.Predicates.html#7977" class="Bound">x</a><a id="7998" class="Symbol">)</a> <a id="8000" class="Symbol">-&gt;</a> <a id="8003" href="Chapter.Logic.Predicates.html#7977" class="Bound">x</a> <a id="8005" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="8008" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="8013" href="Chapter.Logic.Predicates.html#7977" class="Bound">x</a> <a id="8015" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="8017" class="Number">2</a>
<a id="8019" href="Chapter.Logic.Predicates.html#7963" class="Function">theorem-i</a> <a id="8029" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a>      <a id="8044" class="Symbol">=</a> <a id="8046" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="8051" href="Chapter.Logic.Predicates.html#7963" class="Function">theorem-i</a> <a id="8061" class="Symbol">(</a><a id="8062" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="8072" href="Chapter.Logic.Predicates.html#8072" class="Bound">ev</a><a id="8074" class="Symbol">)</a> <a id="8076" class="Symbol">=</a> <a id="8078" href="Library.Equality.html#373" class="Function">cong</a> <a id="8083" class="Symbol">(</a><a id="8084" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="8089" href="Library.Fun.html#112" class="Function Operator">∘</a> <a id="8091" href="Library.Nat.html#59" class="InductiveConstructor">succ</a><a id="8095" class="Symbol">)</a> <a id="8097" class="Symbol">(</a><a id="8098" href="Chapter.Logic.Predicates.html#7963" class="Function">theorem-i</a> <a id="8108" href="Chapter.Logic.Predicates.html#8072" class="Bound">ev</a><a id="8110" class="Symbol">)</a>
</pre>
<h2 id="exercises">Exercises</h2>

<ol>
  <li>Prove that all the provided definitions of evenness are
equivalent, for instance that <code class="language-plaintext highlighter-rouge">Even-p x == true</code> implies <code class="language-plaintext highlighter-rouge">Even-r
x</code>, that <code class="language-plaintext highlighter-rouge">Even-r x</code> implies <code class="language-plaintext highlighter-rouge">Even-i x</code>, that <code class="language-plaintext highlighter-rouge">Even-i x</code> implies
<code class="language-plaintext highlighter-rouge">Even-m x</code> and that <code class="language-plaintext highlighter-rouge">Even-m x</code> implies <code class="language-plaintext highlighter-rouge">Even-p x == true</code>.</li>
  <li>Prove that <code class="language-plaintext highlighter-rouge">x == 1 + x /2 * 2</code> when <code class="language-plaintext highlighter-rouge">¬ Even-i x</code> holds.</li>
  <li>Prove that <code class="language-plaintext highlighter-rouge">Even-i</code> is decidable, namely the theorem <code class="language-plaintext highlighter-rouge">∀(x : ℕ) -&gt;
Decidable (Even-i x)</code>.</li>
  <li>Define an indexed data type <code class="language-plaintext highlighter-rouge">Odd-i</code> analogous to <code class="language-plaintext highlighter-rouge">Even-i</code> but
such that <code class="language-plaintext highlighter-rouge">Odd-i x</code> holds if and only if <code class="language-plaintext highlighter-rouge">x</code> is odd. Prove that
<code class="language-plaintext highlighter-rouge">5</code> is odd and <code class="language-plaintext highlighter-rouge">2</code> is not.</li>
  <li>Prove that <code class="language-plaintext highlighter-rouge">Even-i x ∨ Odd-i x</code> holds and that <code class="language-plaintext highlighter-rouge">Even-i x ∧ Odd-i
x</code> does not for every <code class="language-plaintext highlighter-rouge">x</code>.</li>
  <li>Prove that <code class="language-plaintext highlighter-rouge">Odd-i x</code> implies <code class="language-plaintext highlighter-rouge">x == 1 + x/2 * 2</code> without using
recursion, but reusing the results of exercises 2 and 4.</li>
</ol>

<pre class="Agda solution"><a id="8932" class="Comment">-- EXERCISE 1</a>

<a id="p=&gt;r"></a><a id="8947" href="Chapter.Logic.Predicates.html#8947" class="Function">p=&gt;r</a> <a id="8952" class="Symbol">:</a> <a id="8954" class="Symbol">∀(</a><a id="8956" href="Chapter.Logic.Predicates.html#8956" class="Bound">x</a> <a id="8958" class="Symbol">:</a> <a id="8960" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="8961" class="Symbol">)</a> <a id="8963" class="Symbol">-&gt;</a> <a id="8966" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="8973" href="Chapter.Logic.Predicates.html#8956" class="Bound">x</a> <a id="8975" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="8978" href="Library.Bool.html#52" class="InductiveConstructor">true</a> <a id="8983" class="Symbol">-&gt;</a> <a id="8986" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="8993" href="Chapter.Logic.Predicates.html#8956" class="Bound">x</a>
<a id="8995" href="Chapter.Logic.Predicates.html#8947" class="Function">p=&gt;r</a> <a id="9000" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="9016" href="Chapter.Logic.Predicates.html#9016" class="Bound">eq</a> <a id="9019" class="Symbol">=</a> <a id="9021" href="Library.Logic.html#194" class="InductiveConstructor">&lt;&gt;</a>
<a id="9024" href="Chapter.Logic.Predicates.html#8947" class="Function">p=&gt;r</a> <a id="9029" class="Symbol">(</a><a id="9030" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9035" class="Symbol">(</a><a id="9036" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9041" href="Chapter.Logic.Predicates.html#9041" class="Bound">x</a><a id="9042" class="Symbol">))</a> <a id="9045" href="Chapter.Logic.Predicates.html#9045" class="Bound">eq</a> <a id="9048" class="Symbol">=</a> <a id="9050" href="Chapter.Logic.Predicates.html#8947" class="Function">p=&gt;r</a> <a id="9055" href="Chapter.Logic.Predicates.html#9041" class="Bound">x</a> <a id="9057" href="Chapter.Logic.Predicates.html#9045" class="Bound">eq</a>

<a id="r=&gt;i"></a><a id="9061" href="Chapter.Logic.Predicates.html#9061" class="Function">r=&gt;i</a> <a id="9066" class="Symbol">:</a> <a id="9068" class="Symbol">∀(</a><a id="9070" href="Chapter.Logic.Predicates.html#9070" class="Bound">x</a> <a id="9072" class="Symbol">:</a> <a id="9074" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9075" class="Symbol">)</a> <a id="9077" class="Symbol">-&gt;</a> <a id="9080" href="Chapter.Logic.Predicates.html#4479" class="Function">Even-r</a> <a id="9087" href="Chapter.Logic.Predicates.html#9070" class="Bound">x</a> <a id="9089" class="Symbol">-&gt;</a> <a id="9092" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="9099" href="Chapter.Logic.Predicates.html#9070" class="Bound">x</a>
<a id="9101" href="Chapter.Logic.Predicates.html#9061" class="Function">r=&gt;i</a> <a id="9106" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="9122" href="Chapter.Logic.Predicates.html#9122" class="Bound">ev</a> <a id="9125" class="Symbol">=</a> <a id="9127" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a>
<a id="9137" href="Chapter.Logic.Predicates.html#9061" class="Function">r=&gt;i</a> <a id="9142" class="Symbol">(</a><a id="9143" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9148" class="Symbol">(</a><a id="9149" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9154" href="Chapter.Logic.Predicates.html#9154" class="Bound">x</a><a id="9155" class="Symbol">))</a> <a id="9158" href="Chapter.Logic.Predicates.html#9158" class="Bound">ev</a> <a id="9161" class="Symbol">=</a> <a id="9163" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="9173" class="Symbol">(</a><a id="9174" href="Chapter.Logic.Predicates.html#9061" class="Function">r=&gt;i</a> <a id="9179" href="Chapter.Logic.Predicates.html#9154" class="Bound">x</a> <a id="9181" href="Chapter.Logic.Predicates.html#9158" class="Bound">ev</a><a id="9183" class="Symbol">)</a>

<a id="i=&gt;m"></a><a id="9186" href="Chapter.Logic.Predicates.html#9186" class="Function">i=&gt;m</a> <a id="9191" class="Symbol">:</a> <a id="9193" class="Symbol">∀{</a><a id="9195" href="Chapter.Logic.Predicates.html#9195" class="Bound">x</a> <a id="9197" class="Symbol">:</a> <a id="9199" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9200" class="Symbol">}</a> <a id="9202" class="Symbol">-&gt;</a> <a id="9205" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="9212" href="Chapter.Logic.Predicates.html#9195" class="Bound">x</a> <a id="9214" class="Symbol">-&gt;</a> <a id="9217" href="Chapter.Logic.Predicates.html#2721" class="Function">Even-m</a> <a id="9224" href="Chapter.Logic.Predicates.html#9195" class="Bound">x</a>
<a id="9226" href="Chapter.Logic.Predicates.html#9186" class="Function">i=&gt;m</a> <a id="9231" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a> <a id="9241" class="Symbol">=</a> <a id="9243" class="Number">0</a> <a id="9245" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="9247" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="9252" href="Chapter.Logic.Predicates.html#9186" class="Function">i=&gt;m</a> <a id="9257" class="Symbol">(</a><a id="9258" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="9268" href="Chapter.Logic.Predicates.html#9268" class="Bound">ev</a><a id="9270" class="Symbol">)</a> <a id="9272" class="Keyword">with</a> <a id="9277" href="Chapter.Logic.Predicates.html#9186" class="Function">i=&gt;m</a> <a id="9282" href="Chapter.Logic.Predicates.html#9268" class="Bound">ev</a>
<a id="9285" class="Symbol">...</a> <a id="9289" class="Symbol">|</a> <a id="9291" href="Chapter.Logic.Predicates.html#9291" class="Bound">y</a> <a id="9293" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="9295" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="9300" class="Symbol">=</a> <a id="9302" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9307" href="Chapter.Logic.Predicates.html#9291" class="Bound">y</a> <a id="9309" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="9311" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>

<a id="m=&gt;p"></a><a id="9317" href="Chapter.Logic.Predicates.html#9317" class="Function">m=&gt;p</a> <a id="9322" class="Symbol">:</a> <a id="9324" class="Symbol">∀{</a><a id="9326" href="Chapter.Logic.Predicates.html#9326" class="Bound">x</a> <a id="9328" class="Symbol">:</a> <a id="9330" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9331" class="Symbol">}</a> <a id="9333" class="Symbol">-&gt;</a> <a id="9336" href="Chapter.Logic.Predicates.html#2721" class="Function">Even-m</a> <a id="9343" href="Chapter.Logic.Predicates.html#9326" class="Bound">x</a> <a id="9345" class="Symbol">-&gt;</a> <a id="9348" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="9355" href="Chapter.Logic.Predicates.html#9326" class="Bound">x</a> <a id="9357" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="9360" href="Library.Bool.html#52" class="InductiveConstructor">true</a>
<a id="9365" href="Chapter.Logic.Predicates.html#9317" class="Function">m=&gt;p</a> <a id="9370" class="Symbol">(</a><a id="9371" href="Chapter.Logic.Predicates.html#9371" class="Bound">y</a> <a id="9373" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="9375" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="9379" class="Symbol">)</a> <a id="9381" class="Symbol">=</a> <a id="9383" href="Chapter.Logic.Predicates.html#9401" class="Function">lem</a> <a id="9387" href="Chapter.Logic.Predicates.html#9371" class="Bound">y</a>
  <a id="9391" class="Keyword">where</a>
    <a id="9401" href="Chapter.Logic.Predicates.html#9401" class="Function">lem</a> <a id="9405" class="Symbol">:</a> <a id="9407" class="Symbol">∀(</a><a id="9409" href="Chapter.Logic.Predicates.html#9409" class="Bound">y</a> <a id="9411" class="Symbol">:</a> <a id="9413" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9414" class="Symbol">)</a> <a id="9416" class="Symbol">-&gt;</a> <a id="9419" href="Chapter.Logic.Predicates.html#1388" class="Function">Even-p</a> <a id="9426" class="Symbol">(</a><a id="9427" href="Chapter.Logic.Predicates.html#9409" class="Bound">y</a> <a id="9429" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="9431" class="Number">2</a><a id="9432" class="Symbol">)</a> <a id="9434" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="9437" href="Library.Bool.html#52" class="InductiveConstructor">true</a>
    <a id="9446" href="Chapter.Logic.Predicates.html#9401" class="Function">lem</a> <a id="9450" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="9459" class="Symbol">=</a> <a id="9461" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
    <a id="9470" href="Chapter.Logic.Predicates.html#9401" class="Function">lem</a> <a id="9474" class="Symbol">(</a><a id="9475" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9480" href="Chapter.Logic.Predicates.html#9480" class="Bound">y</a><a id="9481" class="Symbol">)</a> <a id="9483" class="Symbol">=</a> <a id="9485" href="Chapter.Logic.Predicates.html#9401" class="Function">lem</a> <a id="9489" href="Chapter.Logic.Predicates.html#9480" class="Bound">y</a>

<a id="9492" class="Comment">-- EXERCISE 2</a>

<a id="not-even"></a><a id="9507" href="Chapter.Logic.Predicates.html#9507" class="Function">not-even</a> <a id="9516" class="Symbol">:</a> <a id="9518" class="Symbol">∀(</a><a id="9520" href="Chapter.Logic.Predicates.html#9520" class="Bound">x</a> <a id="9522" class="Symbol">:</a> <a id="9524" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9525" class="Symbol">)</a> <a id="9527" class="Symbol">-&gt;</a> <a id="9530" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="9532" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="9539" href="Chapter.Logic.Predicates.html#9520" class="Bound">x</a> <a id="9541" class="Symbol">-&gt;</a> <a id="9544" href="Chapter.Logic.Predicates.html#9520" class="Bound">x</a> <a id="9546" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="9549" class="Number">1</a> <a id="9551" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="9553" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="9558" href="Chapter.Logic.Predicates.html#9520" class="Bound">x</a> <a id="9560" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="9562" class="Number">2</a>
<a id="9564" href="Chapter.Logic.Predicates.html#9507" class="Function">not-even</a> <a id="9573" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="9589" href="Chapter.Logic.Predicates.html#9589" class="Bound">nev</a> <a id="9593" class="Symbol">=</a> <a id="9595" href="Library.Logic.Laws.html#173" class="Function">ex-falso</a> <a id="9604" class="Symbol">(</a><a id="9605" href="Chapter.Logic.Predicates.html#9589" class="Bound">nev</a> <a id="9609" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a><a id="9618" class="Symbol">)</a>
<a id="9620" href="Chapter.Logic.Predicates.html#9507" class="Function">not-even</a> <a id="9629" class="Symbol">(</a><a id="9630" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9635" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="9639" class="Symbol">)</a>     <a id="9645" href="Chapter.Logic.Predicates.html#9645" class="Bound">nev</a> <a id="9649" class="Symbol">=</a> <a id="9651" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="9656" href="Chapter.Logic.Predicates.html#9507" class="Function">not-even</a> <a id="9665" class="Symbol">(</a><a id="9666" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9671" class="Symbol">(</a><a id="9672" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9677" href="Chapter.Logic.Predicates.html#9677" class="Bound">x</a><a id="9678" class="Symbol">))</a> <a id="9681" href="Chapter.Logic.Predicates.html#9681" class="Bound">nev</a> <a id="9685" class="Symbol">=</a> <a id="9687" href="Library.Equality.html#373" class="Function">cong</a> <a id="9692" class="Symbol">(</a><a id="9693" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9698" href="Library.Fun.html#112" class="Function Operator">∘</a> <a id="9700" href="Library.Nat.html#59" class="InductiveConstructor">succ</a><a id="9704" class="Symbol">)</a> <a id="9706" class="Symbol">(</a><a id="9707" href="Chapter.Logic.Predicates.html#9507" class="Function">not-even</a> <a id="9716" href="Chapter.Logic.Predicates.html#9677" class="Bound">x</a> <a id="9718" class="Symbol">(</a><a id="9719" href="Chapter.Logic.Predicates.html#9743" class="Function">lem</a> <a id="9723" href="Chapter.Logic.Predicates.html#9677" class="Bound">x</a> <a id="9725" href="Chapter.Logic.Predicates.html#9681" class="Bound">nev</a><a id="9728" class="Symbol">))</a>
  <a id="9733" class="Keyword">where</a>
    <a id="9743" href="Chapter.Logic.Predicates.html#9743" class="Function">lem</a> <a id="9747" class="Symbol">:</a> <a id="9749" class="Symbol">∀(</a><a id="9751" href="Chapter.Logic.Predicates.html#9751" class="Bound">x</a> <a id="9753" class="Symbol">:</a> <a id="9755" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9756" class="Symbol">)</a> <a id="9758" class="Symbol">-&gt;</a> <a id="9761" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="9763" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="9770" class="Symbol">(</a><a id="9771" class="Number">2</a> <a id="9773" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="9775" href="Chapter.Logic.Predicates.html#9751" class="Bound">x</a><a id="9776" class="Symbol">)</a> <a id="9778" class="Symbol">-&gt;</a> <a id="9781" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="9783" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="9790" href="Chapter.Logic.Predicates.html#9751" class="Bound">x</a>
    <a id="9796" href="Chapter.Logic.Predicates.html#9743" class="Function">lem</a> <a id="9800" href="Chapter.Logic.Predicates.html#9800" class="Bound">x</a> <a id="9802" href="Chapter.Logic.Predicates.html#9802" class="Bound">nev</a> <a id="9806" href="Chapter.Logic.Predicates.html#9806" class="Bound">ev</a> <a id="9809" class="Symbol">=</a> <a id="9811" href="Chapter.Logic.Predicates.html#9802" class="Bound">nev</a> <a id="9815" class="Symbol">(</a><a id="9816" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="9826" href="Chapter.Logic.Predicates.html#9806" class="Bound">ev</a><a id="9828" class="Symbol">)</a>

<a id="9831" class="Comment">-- EXERCISE 3</a>

<a id="Even?"></a><a id="9846" href="Chapter.Logic.Predicates.html#9846" class="Function">Even?</a> <a id="9852" class="Symbol">:</a> <a id="9854" class="Symbol">∀(</a><a id="9856" href="Chapter.Logic.Predicates.html#9856" class="Bound">x</a> <a id="9858" class="Symbol">:</a> <a id="9860" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9861" class="Symbol">)</a> <a id="9863" class="Symbol">-&gt;</a> <a id="9866" href="Library.Logic.html#1544" class="Function">Decidable</a> <a id="9876" class="Symbol">(</a><a id="9877" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="9884" href="Chapter.Logic.Predicates.html#9856" class="Bound">x</a><a id="9885" class="Symbol">)</a>
<a id="9887" href="Chapter.Logic.Predicates.html#9846" class="Function">Even?</a> <a id="9893" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="9909" class="Symbol">=</a> <a id="9911" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="9915" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a>
<a id="9925" href="Chapter.Logic.Predicates.html#9846" class="Function">Even?</a> <a id="9931" class="Symbol">(</a><a id="9932" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9937" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="9941" class="Symbol">)</a>     <a id="9947" class="Symbol">=</a> <a id="9949" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="9953" class="Symbol">λ</a> <a id="9955" class="Symbol">()</a>
<a id="9958" href="Chapter.Logic.Predicates.html#9846" class="Function">Even?</a> <a id="9964" class="Symbol">(</a><a id="9965" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9970" class="Symbol">(</a><a id="9971" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="9976" href="Chapter.Logic.Predicates.html#9976" class="Bound">x</a><a id="9977" class="Symbol">))</a> <a id="9980" class="Keyword">with</a> <a id="9985" href="Chapter.Logic.Predicates.html#9846" class="Function">Even?</a> <a id="9991" href="Chapter.Logic.Predicates.html#9976" class="Bound">x</a>
<a id="9993" class="Symbol">...</a> <a id="9997" class="Symbol">|</a> <a id="9999" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="10003" href="Chapter.Logic.Predicates.html#10003" class="Bound">ev</a>  <a id="10007" class="Symbol">=</a> <a id="10009" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="10013" class="Symbol">(</a><a id="10014" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="10024" href="Chapter.Logic.Predicates.html#10003" class="Bound">ev</a><a id="10026" class="Symbol">)</a>
<a id="10028" class="Symbol">...</a> <a id="10032" class="Symbol">|</a> <a id="10034" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="10038" href="Chapter.Logic.Predicates.html#10038" class="Bound">nev</a> <a id="10042" class="Symbol">=</a> <a id="10044" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="10048" class="Symbol">λ</a> <a id="10050" class="Symbol">{</a> <a id="10052" class="Symbol">(</a><a id="10053" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="10063" href="Chapter.Logic.Predicates.html#10063" class="Bound">ev</a><a id="10065" class="Symbol">)</a> <a id="10067" class="Symbol">→</a> <a id="10069" href="Chapter.Logic.Predicates.html#10038" class="Bound">nev</a> <a id="10073" href="Chapter.Logic.Predicates.html#10063" class="Bound">ev</a> <a id="10076" class="Symbol">}</a>

<a id="10079" class="Comment">-- EXERCISE 4</a>

<a id="10094" class="Keyword">data</a> <a id="Odd-i"></a><a id="10099" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10105" class="Symbol">:</a> <a id="10107" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="10109" class="Symbol">-&gt;</a> <a id="10112" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="10116" class="Keyword">where</a>
  <a id="Odd-i.odd-one"></a><a id="10124" href="Chapter.Logic.Predicates.html#10124" class="InductiveConstructor">odd-one</a>  <a id="10133" class="Symbol">:</a> <a id="10135" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10141" class="Number">1</a>
  <a id="Odd-i.odd-succ"></a><a id="10145" href="Chapter.Logic.Predicates.html#10145" class="InductiveConstructor">odd-succ</a> <a id="10154" class="Symbol">:</a> <a id="10156" class="Symbol">∀{</a><a id="10158" href="Chapter.Logic.Predicates.html#10158" class="Bound">x</a> <a id="10160" class="Symbol">:</a> <a id="10162" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="10163" class="Symbol">}</a> <a id="10165" class="Symbol">-&gt;</a> <a id="10168" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10174" href="Chapter.Logic.Predicates.html#10158" class="Bound">x</a> <a id="10176" class="Symbol">-&gt;</a> <a id="10179" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10185" class="Symbol">(</a><a id="10186" class="Number">2</a> <a id="10188" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="10190" href="Chapter.Logic.Predicates.html#10158" class="Bound">x</a><a id="10191" class="Symbol">)</a>

<a id="10194" href="Chapter.Logic.Predicates.html#10194" class="Function">_</a> <a id="10196" class="Symbol">:</a> <a id="10198" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10204" class="Number">5</a>
<a id="10206" class="Symbol">_</a> <a id="10208" class="Symbol">=</a> <a id="10210" href="Chapter.Logic.Predicates.html#10145" class="InductiveConstructor">odd-succ</a> <a id="10219" class="Symbol">(</a><a id="10220" href="Chapter.Logic.Predicates.html#10145" class="InductiveConstructor">odd-succ</a> <a id="10229" href="Chapter.Logic.Predicates.html#10124" class="InductiveConstructor">odd-one</a><a id="10236" class="Symbol">)</a>

<a id="10239" href="Chapter.Logic.Predicates.html#10239" class="Function">_</a> <a id="10241" class="Symbol">:</a> <a id="10243" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="10245" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10251" class="Number">2</a>
<a id="10253" class="Symbol">_</a> <a id="10255" class="Symbol">=</a> <a id="10257" class="Symbol">λ</a> <a id="10259" class="Symbol">{</a> <a id="10261" class="Symbol">(</a><a id="10262" href="Chapter.Logic.Predicates.html#10145" class="InductiveConstructor">odd-succ</a> <a id="10271" class="Symbol">())</a> <a id="10275" class="Symbol">}</a>

<a id="10278" class="Comment">-- EXERCISE 5</a>

<a id="even-or-odd"></a><a id="10293" href="Chapter.Logic.Predicates.html#10293" class="Function">even-or-odd</a> <a id="10305" class="Symbol">:</a> <a id="10307" class="Symbol">∀(</a><a id="10309" href="Chapter.Logic.Predicates.html#10309" class="Bound">x</a> <a id="10311" class="Symbol">:</a> <a id="10313" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="10314" class="Symbol">)</a> <a id="10316" class="Symbol">-&gt;</a> <a id="10319" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="10326" href="Chapter.Logic.Predicates.html#10309" class="Bound">x</a> <a id="10328" href="Library.Logic.html#1416" class="Datatype Operator">∨</a> <a id="10330" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10336" href="Chapter.Logic.Predicates.html#10309" class="Bound">x</a>
<a id="10338" href="Chapter.Logic.Predicates.html#10293" class="Function">even-or-odd</a> <a id="10350" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="10366" class="Symbol">=</a> <a id="10368" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="10372" href="Chapter.Logic.Predicates.html#7140" class="InductiveConstructor">even-zero</a>
<a id="10382" href="Chapter.Logic.Predicates.html#10293" class="Function">even-or-odd</a> <a id="10394" class="Symbol">(</a><a id="10395" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10400" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="10404" class="Symbol">)</a>     <a id="10410" class="Symbol">=</a> <a id="10412" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="10416" href="Chapter.Logic.Predicates.html#10124" class="InductiveConstructor">odd-one</a>
<a id="10424" href="Chapter.Logic.Predicates.html#10293" class="Function">even-or-odd</a> <a id="10436" class="Symbol">(</a><a id="10437" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10442" class="Symbol">(</a><a id="10443" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10448" href="Chapter.Logic.Predicates.html#10448" class="Bound">x</a><a id="10449" class="Symbol">))</a> <a id="10452" class="Keyword">with</a> <a id="10457" href="Chapter.Logic.Predicates.html#10293" class="Function">even-or-odd</a> <a id="10469" href="Chapter.Logic.Predicates.html#10448" class="Bound">x</a>
<a id="10471" class="Symbol">...</a> <a id="10475" class="Symbol">|</a> <a id="10477" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="10481" href="Chapter.Logic.Predicates.html#10481" class="Bound">ev</a> <a id="10484" class="Symbol">=</a> <a id="10486" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="10490" class="Symbol">(</a><a id="10491" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="10501" href="Chapter.Logic.Predicates.html#10481" class="Bound">ev</a><a id="10503" class="Symbol">)</a>
<a id="10505" class="Symbol">...</a> <a id="10509" class="Symbol">|</a> <a id="10511" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="10515" href="Chapter.Logic.Predicates.html#10515" class="Bound">od</a> <a id="10518" class="Symbol">=</a> <a id="10520" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="10524" class="Symbol">(</a><a id="10525" href="Chapter.Logic.Predicates.html#10145" class="InductiveConstructor">odd-succ</a> <a id="10534" href="Chapter.Logic.Predicates.html#10515" class="Bound">od</a><a id="10536" class="Symbol">)</a>

<a id="even-and-odd"></a><a id="10539" href="Chapter.Logic.Predicates.html#10539" class="Function">even-and-odd</a> <a id="10552" class="Symbol">:</a> <a id="10554" class="Symbol">∀(</a><a id="10556" href="Chapter.Logic.Predicates.html#10556" class="Bound">x</a> <a id="10558" class="Symbol">:</a> <a id="10560" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="10561" class="Symbol">)</a> <a id="10563" class="Symbol">-&gt;</a> <a id="10566" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="10568" class="Symbol">(</a><a id="10569" href="Chapter.Logic.Predicates.html#7114" class="Datatype">Even-i</a> <a id="10576" href="Chapter.Logic.Predicates.html#10556" class="Bound">x</a> <a id="10578" href="Library.Logic.html#1349" class="Function Operator">∧</a> <a id="10580" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10586" href="Chapter.Logic.Predicates.html#10556" class="Bound">x</a><a id="10587" class="Symbol">)</a>
<a id="10589" href="Chapter.Logic.Predicates.html#10539" class="Function">even-and-odd</a> <a id="10602" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="10618" class="Symbol">(_</a>  <a id="10622" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10624" class="Symbol">())</a>
<a id="10628" href="Chapter.Logic.Predicates.html#10539" class="Function">even-and-odd</a> <a id="10641" class="Symbol">(</a><a id="10642" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10647" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="10651" class="Symbol">)</a>     <a id="10657" class="Symbol">(()</a> <a id="10661" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10663" class="Symbol">_</a> <a id="10665" class="Symbol">)</a>
<a id="10667" href="Chapter.Logic.Predicates.html#10539" class="Function">even-and-odd</a> <a id="10680" class="Symbol">(</a><a id="10681" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10686" class="Symbol">(</a><a id="10687" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10692" href="Chapter.Logic.Predicates.html#10692" class="Bound">x</a><a id="10693" class="Symbol">))</a> <a id="10696" class="Symbol">(</a><a id="10697" href="Chapter.Logic.Predicates.html#7163" class="InductiveConstructor">even-succ</a> <a id="10707" href="Chapter.Logic.Predicates.html#10707" class="Bound">ev</a> <a id="10710" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10712" href="Chapter.Logic.Predicates.html#10145" class="InductiveConstructor">odd-succ</a> <a id="10721" href="Chapter.Logic.Predicates.html#10721" class="Bound">od</a><a id="10723" class="Symbol">)</a> <a id="10725" class="Symbol">=</a> <a id="10727" href="Chapter.Logic.Predicates.html#10539" class="Function">even-and-odd</a> <a id="10740" href="Chapter.Logic.Predicates.html#10692" class="Bound">x</a> <a id="10742" class="Symbol">(</a><a id="10743" href="Chapter.Logic.Predicates.html#10707" class="Bound">ev</a> <a id="10746" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10748" href="Chapter.Logic.Predicates.html#10721" class="Bound">od</a><a id="10750" class="Symbol">)</a>

<a id="10753" class="Comment">-- EXERCISE 6</a>

<a id="odd"></a><a id="10768" href="Chapter.Logic.Predicates.html#10768" class="Function">odd</a> <a id="10772" class="Symbol">:</a> <a id="10774" class="Symbol">∀{</a><a id="10776" href="Chapter.Logic.Predicates.html#10776" class="Bound">x</a> <a id="10778" class="Symbol">:</a> <a id="10780" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="10781" class="Symbol">}</a> <a id="10783" class="Symbol">-&gt;</a> <a id="10786" href="Chapter.Logic.Predicates.html#10099" class="Datatype">Odd-i</a> <a id="10792" href="Chapter.Logic.Predicates.html#10776" class="Bound">x</a> <a id="10794" class="Symbol">-&gt;</a> <a id="10797" href="Chapter.Logic.Predicates.html#10776" class="Bound">x</a> <a id="10799" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="10802" class="Number">1</a> <a id="10804" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="10806" href="Chapter.Logic.Predicates.html#569" class="Function">half</a> <a id="10811" href="Chapter.Logic.Predicates.html#10776" class="Bound">x</a> <a id="10813" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="10815" class="Number">2</a>
<a id="10817" href="Chapter.Logic.Predicates.html#10768" class="Function">odd</a> <a id="10821" class="Symbol">{</a><a id="10822" href="Chapter.Logic.Predicates.html#10822" class="Bound">x</a><a id="10823" class="Symbol">}</a> <a id="10825" href="Chapter.Logic.Predicates.html#10825" class="Bound">od</a> <a id="10828" class="Symbol">=</a> <a id="10830" href="Chapter.Logic.Predicates.html#9507" class="Function">not-even</a> <a id="10839" href="Chapter.Logic.Predicates.html#10822" class="Bound">x</a> <a id="10841" class="Symbol">(</a><a id="10842" href="Library.Logic.Laws.html#289" class="Function">contraposition</a> <a id="10857" class="Symbol">(</a><a id="10858" href="Library.Logic.html#271" class="InductiveConstructor Operator">_,</a> <a id="10861" href="Chapter.Logic.Predicates.html#10825" class="Bound">od</a><a id="10863" class="Symbol">)</a> <a id="10865" class="Symbol">(</a><a id="10866" href="Chapter.Logic.Predicates.html#10539" class="Function">even-and-odd</a> <a id="10879" href="Chapter.Logic.Predicates.html#10822" class="Bound">x</a><a id="10880" class="Symbol">))</a>
</pre>

  </div>
  <ul class="menu">
  <li>
    <a href="Chapter.Logic.Existential.html">‹ Existential quantification</a></li>
  <li>
    <a href="Chapter.Logic.Equality.html">Equality ›</a></li>
</ul>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>
  <div class="wrapper">
    <!-- <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"> -->
    <!--   <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"/> -->
    <!-- </a> -->
    2022-2023
    <a href="https://boystrange.github.io">Luca Padovani</a>
    and <a href="http://www.di.unito.it/~deligu/">Ugo de'Liguoro</a>.
    Page generated on 20 Sep 2023.
  </div>
</footer>
</body>

</html>
