<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Existential quantification | Introduction to Program Verification in Agda</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Existential quantification" />
<meta property="og:locale" content="en_US" />
<meta property="og:site_name" content="Introduction to Program Verification in Agda" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Existential quantification" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Existential quantification","url":"/pages/Chapter.Logic.Existential.html"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/Agda.css">
  <script src="../assets/js/mathjax.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="../assets/js/codereveal.js"></script>
  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Introduction to Program Verification in Agda" /><!-- <script src="/assets/js/clipboard.min.js"></script> -->
  <!-- <script src="/assets/js/codeselect.js"></script> -->
</head>
<body>

<header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="../index.html">Introduction to Program Verification in Agda</a>
    

    <nav class="site-nav">
      <a href="https://agda.readthedocs.io/en/latest/">AGDA DOCS</a>
    </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <ul class="menu">
  <li>
    <a href="Chapter.Logic.Negation.html">‹ Negation and decidability</a></li>
  <li>
    <a href="Chapter.Logic.Predicates.html">Defining predicates ›</a></li>
</ul>
  <header class="post-header">
    <h1 class="post-title">Existential quantification</h1>
  </header>

  <div class="post-content">
    <pre class="Agda"><a id="110" class="Keyword">module</a> <a id="117" href="Chapter.Logic.Existential.html" class="Module">Chapter.Logic.Existential</a> <a id="143" class="Keyword">where</a>
</pre>
<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="170" class="Keyword">open</a> <a id="175" class="Keyword">import</a> <a id="182" href="Library.Fun.html" class="Module">Library.Fun</a>
<a id="194" class="Keyword">open</a> <a id="199" class="Keyword">import</a> <a id="206" href="Library.Bool.html" class="Module">Library.Bool</a>
<a id="219" class="Keyword">open</a> <a id="224" class="Keyword">import</a> <a id="231" href="Library.Nat.html" class="Module">Library.Nat</a>
<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="Library.Nat.Properties.html" class="Module">Library.Nat.Properties</a>
<a id="278" class="Keyword">open</a> <a id="283" class="Keyword">import</a> <a id="290" href="Library.List.html" class="Module">Library.List</a>
<a id="303" class="Keyword">open</a> <a id="308" class="Keyword">import</a> <a id="315" href="Library.Equality.html" class="Module">Library.Equality</a>
<a id="332" class="Keyword">open</a> <a id="337" class="Keyword">import</a> <a id="344" href="Library.Logic.html" class="Module">Library.Logic</a> <a id="358" class="Keyword">hiding</a> <a id="365" class="Symbol">(</a><a id="366" href="Library.Logic.html#414" class="Function">fst</a><a id="369" class="Symbol">;</a> <a id="371" href="Library.Logic.html#483" class="Function">snd</a><a id="374" class="Symbol">)</a>
<a id="376" class="Keyword">open</a> <a id="381" class="Keyword">import</a> <a id="388" href="Library.Logic.Laws.html" class="Module">Library.Logic.Laws</a>
</pre>
<h2 id="defining-the-existential-quantifier">Defining the existential quantifier</h2>

<p>In constructive logic, the proof of a predicate of the form $∃x\in
A.P(x)$ is a <strong>pair</strong> consisting of a particular element $x$ of $A$
called <em>witness</em> along with a proof that $x$ satisfies the predicate
$P$. This is an example of <strong>dependent pair</strong> where the type of the
second component depends on the value $x$ of the first one. The data
type that we use to represent dependent pairs is traditionally
called “sigma type” and is a refinement of the type <code class="language-plaintext highlighter-rouge">_∧_</code> we have
defined in a <a href="Chapter.Logic.Connectives.html#conjunction">previous
chapter</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data Σ (A : Set) (B : A -&gt; Set) : Set where
  _,_ : ∀(x : A) -&gt; B x -&gt; Σ A B
</code></pre></div></div>

<p>The <em>non-dependent</em> pair type can be defined as an instance of a
sigma type where the type of the second component does <em>not</em> depend
on the value of the first one.</p>

<pre class="Agda"><a id="_×_"></a><a id="1255" href="Chapter.Logic.Existential.html#1255" class="Function Operator">_×_</a> <a id="1259" class="Symbol">:</a> <a id="1261" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1265" class="Symbol">-&gt;</a> <a id="1268" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1272" class="Symbol">-&gt;</a> <a id="1275" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1279" href="Chapter.Logic.Existential.html#1279" class="Bound">A</a> <a id="1281" href="Chapter.Logic.Existential.html#1255" class="Function Operator">×</a> <a id="1283" href="Chapter.Logic.Existential.html#1283" class="Bound">B</a> <a id="1285" class="Symbol">=</a> <a id="1287" href="Library.Logic.html#222" class="Datatype">Σ</a> <a id="1289" href="Chapter.Logic.Existential.html#1279" class="Bound">A</a> <a id="1291" class="Symbol">λ</a> <a id="1293" href="Chapter.Logic.Existential.html#1293" class="Bound">_</a> <a id="1295" class="Symbol">-&gt;</a> <a id="1298" href="Chapter.Logic.Existential.html#1283" class="Bound">B</a>
</pre>
<p>The two projections <code class="language-plaintext highlighter-rouge">fst</code> and <code class="language-plaintext highlighter-rouge">snd</code> for sigma types are the same we
have already defined for <code class="language-plaintext highlighter-rouge">_∧_</code>, except for their type. In
particular, the type of <code class="language-plaintext highlighter-rouge">snd</code> refers to the first component of a
dependent pair by means of <code class="language-plaintext highlighter-rouge">fst</code>.</p>

<pre class="Agda"><a id="fst"></a><a id="1535" href="Chapter.Logic.Existential.html#1535" class="Function">fst</a> <a id="1539" class="Symbol">:</a> <a id="1541" class="Symbol">∀{</a><a id="1543" href="Chapter.Logic.Existential.html#1543" class="Bound">A</a> <a id="1545" class="Symbol">:</a> <a id="1547" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1550" class="Symbol">}</a> <a id="1552" class="Symbol">{</a><a id="1553" href="Chapter.Logic.Existential.html#1553" class="Bound">B</a> <a id="1555" class="Symbol">:</a> <a id="1557" href="Chapter.Logic.Existential.html#1543" class="Bound">A</a> <a id="1559" class="Symbol">-&gt;</a> <a id="1562" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1565" class="Symbol">}</a> <a id="1567" class="Symbol">-&gt;</a> <a id="1570" href="Library.Logic.html#222" class="Datatype">Σ</a> <a id="1572" href="Chapter.Logic.Existential.html#1543" class="Bound">A</a> <a id="1574" href="Chapter.Logic.Existential.html#1553" class="Bound">B</a> <a id="1576" class="Symbol">-&gt;</a> <a id="1579" href="Chapter.Logic.Existential.html#1543" class="Bound">A</a>
<a id="1581" href="Chapter.Logic.Existential.html#1535" class="Function">fst</a> <a id="1585" class="Symbol">(</a><a id="1586" href="Chapter.Logic.Existential.html#1586" class="Bound">x</a> <a id="1588" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="1590" class="Symbol">_)</a> <a id="1593" class="Symbol">=</a> <a id="1595" href="Chapter.Logic.Existential.html#1586" class="Bound">x</a>

<a id="snd"></a><a id="1598" href="Chapter.Logic.Existential.html#1598" class="Function">snd</a> <a id="1602" class="Symbol">:</a> <a id="1604" class="Symbol">∀{</a><a id="1606" href="Chapter.Logic.Existential.html#1606" class="Bound">A</a> <a id="1608" class="Symbol">:</a> <a id="1610" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1613" class="Symbol">}</a> <a id="1615" class="Symbol">{</a><a id="1616" href="Chapter.Logic.Existential.html#1616" class="Bound">B</a> <a id="1618" class="Symbol">:</a> <a id="1620" href="Chapter.Logic.Existential.html#1606" class="Bound">A</a> <a id="1622" class="Symbol">-&gt;</a> <a id="1625" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1628" class="Symbol">}</a> <a id="1630" class="Symbol">(</a><a id="1631" href="Chapter.Logic.Existential.html#1631" class="Bound">p</a> <a id="1633" class="Symbol">:</a> <a id="1635" href="Library.Logic.html#222" class="Datatype">Σ</a> <a id="1637" href="Chapter.Logic.Existential.html#1606" class="Bound">A</a> <a id="1639" href="Chapter.Logic.Existential.html#1616" class="Bound">B</a><a id="1640" class="Symbol">)</a> <a id="1642" class="Symbol">-&gt;</a> <a id="1645" href="Chapter.Logic.Existential.html#1616" class="Bound">B</a> <a id="1647" class="Symbol">(</a><a id="1648" href="Chapter.Logic.Existential.html#1535" class="Function">fst</a> <a id="1652" href="Chapter.Logic.Existential.html#1631" class="Bound">p</a><a id="1653" class="Symbol">)</a>
<a id="1655" href="Chapter.Logic.Existential.html#1598" class="Function">snd</a> <a id="1659" class="Symbol">(_</a> <a id="1662" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="1664" href="Chapter.Logic.Existential.html#1664" class="Bound">y</a><a id="1665" class="Symbol">)</a> <a id="1667" class="Symbol">=</a> <a id="1669" href="Chapter.Logic.Existential.html#1664" class="Bound">y</a>
</pre>
<p>Sigma types have plenty of uses in the specification and
verification of programs. Below we see a few examples.</p>

<h2 id="refined-types">Refined types</h2>

<p>We can use sigma types to <em>refine</em> an existing type to some elements
that have a certain property. For example, we can define the type of
non-null natural numbers as follows.</p>

<pre class="Agda"><a id="ℕ⁺"></a><a id="1987" href="Chapter.Logic.Existential.html#1987" class="Function">ℕ⁺</a> <a id="1990" class="Symbol">:</a> <a id="1992" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1996" href="Chapter.Logic.Existential.html#1987" class="Function">ℕ⁺</a> <a id="1999" class="Symbol">=</a> <a id="2001" href="Library.Logic.html#222" class="Datatype">Σ</a> <a id="2003" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="2005" class="Symbol">(</a><a id="2006" href="Library.Equality.html#140" class="Function Operator">_!=</a> <a id="2010" class="Number">0</a><a id="2011" class="Symbol">)</a>
</pre>
<p>A non-null natural number, that is an element of the type <code class="language-plaintext highlighter-rouge">ℕ⁺</code>, is a
pair consisting of some natural number <code class="language-plaintext highlighter-rouge">x</code> and a proof that <code class="language-plaintext highlighter-rouge">x</code> is
different from <code class="language-plaintext highlighter-rouge">0</code>. For example, <code class="language-plaintext highlighter-rouge">1</code> is an element of <code class="language-plaintext highlighter-rouge">ℕ⁺</code>.</p>

<pre class="Agda"><a id="2219" href="Chapter.Logic.Existential.html#2219" class="Function">_</a> <a id="2221" class="Symbol">:</a> <a id="2223" href="Chapter.Logic.Existential.html#1987" class="Function">ℕ⁺</a>
<a id="2226" class="Symbol">_</a> <a id="2228" class="Symbol">=</a> <a id="2230" class="Number">1</a> <a id="2232" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="2234" class="Symbol">λ</a> <a id="2236" class="Symbol">()</a>
</pre>
<p>Analogously, we can define the type of non-empty lists as follows.</p>

<pre class="Agda"><a id="List⁺"></a><a id="2316" href="Chapter.Logic.Existential.html#2316" class="Function">List⁺</a> <a id="2322" class="Symbol">:</a> <a id="2324" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2328" class="Symbol">-&gt;</a> <a id="2331" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="2335" href="Chapter.Logic.Existential.html#2316" class="Function">List⁺</a> <a id="2341" href="Chapter.Logic.Existential.html#2341" class="Bound">A</a> <a id="2343" class="Symbol">=</a> <a id="2345" href="Library.Logic.html#222" class="Datatype">Σ</a> <a id="2347" class="Symbol">(</a><a id="2348" href="Library.List.html#84" class="Datatype">List</a> <a id="2353" href="Chapter.Logic.Existential.html#2341" class="Bound">A</a><a id="2354" class="Symbol">)</a> <a id="2356" class="Symbol">(</a><a id="2357" href="Library.Equality.html#140" class="Function Operator">_!=</a> <a id="2361" href="Library.List.html#113" class="InductiveConstructor">[]</a><a id="2363" class="Symbol">)</a>
</pre>
<h2 id="partial-functions">Partial functions</h2>

<p>Type refinements may be useful for the implementation of <em>partial
functions</em> that are only defined for a subset of their
domain. Typical examples are division, which is defined only for
non-null divisors, and the functions <code class="language-plaintext highlighter-rouge">head</code> and <code class="language-plaintext highlighter-rouge">tail</code> that
respectively return the head and the tail of a non-empty list.</p>

<pre class="Agda"><a id="head"></a><a id="2706" href="Chapter.Logic.Existential.html#2706" class="Function">head</a> <a id="2711" class="Symbol">:</a> <a id="2713" class="Symbol">∀{</a><a id="2715" href="Chapter.Logic.Existential.html#2715" class="Bound">A</a> <a id="2717" class="Symbol">:</a> <a id="2719" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="2722" class="Symbol">}</a> <a id="2724" class="Symbol">-&gt;</a> <a id="2727" href="Chapter.Logic.Existential.html#2316" class="Function">List⁺</a> <a id="2733" href="Chapter.Logic.Existential.html#2715" class="Bound">A</a> <a id="2735" class="Symbol">-&gt;</a> <a id="2738" href="Chapter.Logic.Existential.html#2715" class="Bound">A</a>
<a id="2740" href="Chapter.Logic.Existential.html#2706" class="Function">head</a> <a id="2745" class="Symbol">(</a><a id="2746" href="Library.List.html#113" class="InductiveConstructor">[]</a>      <a id="2754" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="2756" href="Chapter.Logic.Existential.html#2756" class="Bound">nempty</a><a id="2762" class="Symbol">)</a> <a id="2764" class="Symbol">=</a> <a id="2766" href="Library.Logic.Laws.html#173" class="Function">ex-falso</a> <a id="2775" class="Symbol">(</a><a id="2776" href="Chapter.Logic.Existential.html#2756" class="Bound">nempty</a> <a id="2783" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="2787" class="Symbol">)</a>
<a id="2789" href="Chapter.Logic.Existential.html#2706" class="Function">head</a> <a id="2794" class="Symbol">(</a><a id="2795" href="Chapter.Logic.Existential.html#2795" class="Bound">x</a> <a id="2797" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="2800" class="Symbol">_</a>  <a id="2803" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="2805" class="Symbol">_</a>     <a id="2811" class="Symbol">)</a> <a id="2813" class="Symbol">=</a> <a id="2815" href="Chapter.Logic.Existential.html#2795" class="Bound">x</a>

<a id="tail"></a><a id="2818" href="Chapter.Logic.Existential.html#2818" class="Function">tail</a> <a id="2823" class="Symbol">:</a> <a id="2825" class="Symbol">∀{</a><a id="2827" href="Chapter.Logic.Existential.html#2827" class="Bound">A</a> <a id="2829" class="Symbol">:</a> <a id="2831" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="2834" class="Symbol">}</a> <a id="2836" class="Symbol">-&gt;</a> <a id="2839" href="Chapter.Logic.Existential.html#2316" class="Function">List⁺</a> <a id="2845" href="Chapter.Logic.Existential.html#2827" class="Bound">A</a> <a id="2847" class="Symbol">-&gt;</a> <a id="2850" href="Library.List.html#84" class="Datatype">List</a> <a id="2855" href="Chapter.Logic.Existential.html#2827" class="Bound">A</a>
<a id="2857" href="Chapter.Logic.Existential.html#2818" class="Function">tail</a> <a id="2862" class="Symbol">(</a><a id="2863" href="Library.List.html#113" class="InductiveConstructor">[]</a>      <a id="2871" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="2873" href="Chapter.Logic.Existential.html#2873" class="Bound">nempty</a><a id="2879" class="Symbol">)</a> <a id="2881" class="Symbol">=</a> <a id="2883" href="Library.Logic.Laws.html#173" class="Function">ex-falso</a> <a id="2892" class="Symbol">(</a><a id="2893" href="Chapter.Logic.Existential.html#2873" class="Bound">nempty</a> <a id="2900" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="2904" class="Symbol">)</a>
<a id="2906" href="Chapter.Logic.Existential.html#2818" class="Function">tail</a> <a id="2911" class="Symbol">(_</a> <a id="2914" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="2917" href="Chapter.Logic.Existential.html#2917" class="Bound">xs</a> <a id="2920" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="2922" class="Symbol">_</a>     <a id="2928" class="Symbol">)</a> <a id="2930" class="Symbol">=</a> <a id="2932" href="Chapter.Logic.Existential.html#2917" class="Bound">xs</a>
</pre>
<p>In the definition of <code class="language-plaintext highlighter-rouge">head</code> and <code class="language-plaintext highlighter-rouge">tail</code> we perform case analysis on
an element of type <code class="language-plaintext highlighter-rouge">List⁺ A</code>, which is a pair consisting of a list
and a proof that the list is not empty. We further analyze the
structure of the list. Agda is not able to automatically rule out
the case in which the list is <code class="language-plaintext highlighter-rouge">[]</code>. However, this case is made
impossible by the proof <code class="language-plaintext highlighter-rouge">nempty</code> that the list is not empty, hence
we can honor our obligation to yield a result of the desired type by
invoking <code class="language-plaintext highlighter-rouge">ex-falso</code>. When the list is not empty, we simply return
the right component.</p>

<h2 id="intrinsic-verification">Intrinsic verification</h2>

<p>Another typical use case of sigma types is in providing type-rich
information about the result returned by a function. For example,
suppose we wish to implement a function <code class="language-plaintext highlighter-rouge">pred</code> that, applied to a
natural number different from <code class="language-plaintext highlighter-rouge">0</code> (that is, an element of <code class="language-plaintext highlighter-rouge">ℕ⁺</code>),
returns its predecessor. We could implement <code class="language-plaintext highlighter-rouge">pred</code> simply as a
function of type <code class="language-plaintext highlighter-rouge">ℕ⁺ -&gt; ℕ</code>, however this type would not provide any
information about the property of the returned result. In fact, such
function could return any number, not necessarily the desired
one. Alternatively, we could implement <code class="language-plaintext highlighter-rouge">pred</code> so that it returns a
natural number along with a proof that its successor is the number
passed to the function. But this is just what a sigma type allows us
to do. To make the syntax evocative of the fact that we are
describing the existence of a term with a certain property the Agda
library defines</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∃[ x ] A
</code></pre></div></div>

<p>as syntactic sugar for</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Σ _ λ x -&gt; A
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">x</code> typically occurs in <code class="language-plaintext highlighter-rouge">A</code> and the underscore is a
placeholder for the type of the first component of the dependent
pair, which can be automatically inferred by Agda in many
cases. With the help of this syntax we define <code class="language-plaintext highlighter-rouge">pred</code> thus.</p>

<pre class="Agda"><a id="pred"></a><a id="4691" href="Chapter.Logic.Existential.html#4691" class="Function">pred</a> <a id="4696" class="Symbol">:</a> <a id="4698" class="Symbol">∀(</a><a id="4700" href="Chapter.Logic.Existential.html#4700" class="Bound">p</a> <a id="4702" class="Symbol">:</a> <a id="4704" href="Chapter.Logic.Existential.html#1987" class="Function">ℕ⁺</a><a id="4706" class="Symbol">)</a> <a id="4708" class="Symbol">-&gt;</a> <a id="4711" href="Library.Logic.html#632" class="Function">∃[</a> <a id="4714" href="Chapter.Logic.Existential.html#4714" class="Bound">x</a> <a id="4716" href="Library.Logic.html#632" class="Function">]</a> <a id="4718" href="Chapter.Logic.Existential.html#1535" class="Function">fst</a> <a id="4722" href="Chapter.Logic.Existential.html#4700" class="Bound">p</a> <a id="4724" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="4727" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4732" href="Chapter.Logic.Existential.html#4714" class="Bound">x</a>
<a id="4734" href="Chapter.Logic.Existential.html#4691" class="Function">pred</a> <a id="4739" class="Symbol">(</a><a id="4740" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>   <a id="4747" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="4749" href="Chapter.Logic.Existential.html#4749" class="Bound">nzero</a><a id="4754" class="Symbol">)</a> <a id="4756" class="Symbol">=</a> <a id="4758" href="Library.Logic.Laws.html#173" class="Function">ex-falso</a> <a id="4767" class="Symbol">(</a><a id="4768" href="Chapter.Logic.Existential.html#4749" class="Bound">nzero</a> <a id="4774" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="4778" class="Symbol">)</a>
<a id="4780" href="Chapter.Logic.Existential.html#4691" class="Function">pred</a> <a id="4785" class="Symbol">(</a><a id="4786" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="4791" href="Chapter.Logic.Existential.html#4791" class="Bound">x</a> <a id="4793" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="4795" class="Symbol">_</a>    <a id="4800" class="Symbol">)</a> <a id="4802" class="Symbol">=</a> <a id="4804" href="Chapter.Logic.Existential.html#4791" class="Bound">x</a> <a id="4806" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="4808" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
</pre>
<p>Note the use of <code class="language-plaintext highlighter-rouge">fst</code> in the type of <code class="language-plaintext highlighter-rouge">pred</code> to refer to the first
component of the pair <code class="language-plaintext highlighter-rouge">p</code>. As usual, we perform case analysis on the
argument of type <code class="language-plaintext highlighter-rouge">ℕ⁺</code>, further analyzing the witness in the
pair. Once we have established that this must have the form <code class="language-plaintext highlighter-rouge">succ
x</code>, we return <code class="language-plaintext highlighter-rouge">x</code> along with the proof that this is the correct
result.</p>

<p>The definition of functions whose type specifies their behavior in
detail is called <em>intrinsic verification</em>. We will see more
substantial examples of this technique in later sections.</p>

<h2 id="defining-predicates">Defining predicates</h2>

<p>As final use case for existential quantification we consider the
definition of a binary predicate <code class="language-plaintext highlighter-rouge">x ∣ y</code> indicating that <code class="language-plaintext highlighter-rouge">x</code> divides
<code class="language-plaintext highlighter-rouge">y</code>. This relation among <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> can be expressed as the
existence of some natural number <code class="language-plaintext highlighter-rouge">z</code> such that <code class="language-plaintext highlighter-rouge">z</code> times <code class="language-plaintext highlighter-rouge">x</code> results
into <code class="language-plaintext highlighter-rouge">y</code>.</p>

<pre class="Agda"><a id="_∣_"></a><a id="5641" href="Chapter.Logic.Existential.html#5641" class="Function Operator">_∣_</a> <a id="5645" class="Symbol">:</a> <a id="5647" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="5649" class="Symbol">-&gt;</a> <a id="5652" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="5654" class="Symbol">-&gt;</a> <a id="5657" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="5661" href="Chapter.Logic.Existential.html#5661" class="Bound">x</a> <a id="5663" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="5665" href="Chapter.Logic.Existential.html#5665" class="Bound">y</a> <a id="5667" class="Symbol">=</a> <a id="5669" href="Library.Logic.html#632" class="Function">∃[</a> <a id="5672" href="Chapter.Logic.Existential.html#5672" class="Bound">z</a> <a id="5674" href="Library.Logic.html#632" class="Function">]</a> <a id="5676" href="Chapter.Logic.Existential.html#5672" class="Bound">z</a> <a id="5678" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="5680" href="Chapter.Logic.Existential.html#5661" class="Bound">x</a> <a id="5682" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="5685" href="Chapter.Logic.Existential.html#5665" class="Bound">y</a>
</pre>
<p>For example, the type <code class="language-plaintext highlighter-rouge">2 ∣ 64</code> is inhabited by the witness <code class="language-plaintext highlighter-rouge">32</code>
along with a proof that <code class="language-plaintext highlighter-rouge">32 * 2</code> is equal to <code class="language-plaintext highlighter-rouge">64</code>.</p>

<pre class="Agda"><a id="5812" href="Chapter.Logic.Existential.html#5812" class="Function">_</a> <a id="5814" class="Symbol">:</a> <a id="5816" class="Number">2</a> <a id="5818" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="5820" class="Number">64</a>
<a id="5823" class="Symbol">_</a> <a id="5825" class="Symbol">=</a> <a id="5827" class="Number">32</a> <a id="5830" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="5832" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
</pre>
<p>Beware that the symbol <code class="language-plaintext highlighter-rouge">∣</code> used here and in the rest of this chapter
is the Unicode character obtained by the combination <code class="language-plaintext highlighter-rouge">\|</code>
(backslash-bar) and is different from the mere vertical bar <code class="language-plaintext highlighter-rouge">|</code>,
which is one of the few symbols that have a special meaning and are
reserved by Agda.</p>

<p>We can prove that <code class="language-plaintext highlighter-rouge">∣</code> is a partial order on natural number by
showing that it is reflexive, antisymmetric and
transitive. Reflexivity is shown by taking <code class="language-plaintext highlighter-rouge">1</code> as witness along with
the proof that <code class="language-plaintext highlighter-rouge">1</code> is the left unit of multiplication.</p>

<pre class="Agda"><a id="∣-refl"></a><a id="6360" href="Chapter.Logic.Existential.html#6360" class="Function">∣-refl</a> <a id="6367" class="Symbol">:</a> <a id="6369" class="Symbol">∀{</a><a id="6371" href="Chapter.Logic.Existential.html#6371" class="Bound">x</a> <a id="6373" class="Symbol">:</a> <a id="6375" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="6376" class="Symbol">}</a> <a id="6378" class="Symbol">-&gt;</a> <a id="6381" href="Chapter.Logic.Existential.html#6371" class="Bound">x</a> <a id="6383" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="6385" href="Chapter.Logic.Existential.html#6371" class="Bound">x</a>
<a id="6387" href="Chapter.Logic.Existential.html#6360" class="Function">∣-refl</a> <a id="6394" class="Symbol">{</a><a id="6395" href="Chapter.Logic.Existential.html#6395" class="Bound">x</a><a id="6396" class="Symbol">}</a> <a id="6398" class="Symbol">=</a> <a id="6400" class="Number">1</a> <a id="6402" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="6404" href="Library.Nat.Properties.html#1294" class="Function">*-unit-l</a> <a id="6413" href="Chapter.Logic.Existential.html#6395" class="Bound">x</a>
</pre>
<p>Concerning transitivity, by pattern matching on the proofs of <code class="language-plaintext highlighter-rouge">x ∣
y</code> and <code class="language-plaintext highlighter-rouge">y ∣ z</code> we find out two witnesses <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> such that <code class="language-plaintext highlighter-rouge">u *
x == y</code> and <code class="language-plaintext highlighter-rouge">v * (u * x) == z</code>. The witness proving that <code class="language-plaintext highlighter-rouge">x</code> divides
<code class="language-plaintext highlighter-rouge">z</code> is <code class="language-plaintext highlighter-rouge">v * u</code>, but we have to reassociate the product <code class="language-plaintext highlighter-rouge">v * (u * x)</code>
into <code class="language-plaintext highlighter-rouge">(v * u) * x</code> in order to show that it serves the desired
purpose.</p>

<pre class="Agda"><a id="∣-trans"></a><a id="6770" href="Chapter.Logic.Existential.html#6770" class="Function">∣-trans</a> <a id="6778" class="Symbol">:</a> <a id="6780" class="Symbol">∀{</a><a id="6782" href="Chapter.Logic.Existential.html#6782" class="Bound">x</a> <a id="6784" href="Chapter.Logic.Existential.html#6784" class="Bound">y</a> <a id="6786" href="Chapter.Logic.Existential.html#6786" class="Bound">z</a> <a id="6788" class="Symbol">:</a> <a id="6790" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="6791" class="Symbol">}</a> <a id="6793" class="Symbol">-&gt;</a> <a id="6796" href="Chapter.Logic.Existential.html#6782" class="Bound">x</a> <a id="6798" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="6800" href="Chapter.Logic.Existential.html#6784" class="Bound">y</a> <a id="6802" class="Symbol">-&gt;</a> <a id="6805" href="Chapter.Logic.Existential.html#6784" class="Bound">y</a> <a id="6807" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="6809" href="Chapter.Logic.Existential.html#6786" class="Bound">z</a> <a id="6811" class="Symbol">-&gt;</a> <a id="6814" href="Chapter.Logic.Existential.html#6782" class="Bound">x</a> <a id="6816" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="6818" href="Chapter.Logic.Existential.html#6786" class="Bound">z</a>
<a id="6820" href="Chapter.Logic.Existential.html#6770" class="Function">∣-trans</a> <a id="6828" class="Symbol">(</a><a id="6829" href="Chapter.Logic.Existential.html#6829" class="Bound">u</a> <a id="6831" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="6833" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="6837" class="Symbol">)</a> <a id="6839" class="Symbol">(</a><a id="6840" href="Chapter.Logic.Existential.html#6840" class="Bound">v</a> <a id="6842" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="6844" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="6848" class="Symbol">)</a> <a id="6850" class="Symbol">=</a> <a id="6852" href="Chapter.Logic.Existential.html#6840" class="Bound">v</a> <a id="6854" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="6856" href="Chapter.Logic.Existential.html#6829" class="Bound">u</a> <a id="6858" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="6860" href="Library.Equality.html#226" class="Function">symm</a> <a id="6865" class="Symbol">(</a><a id="6866" href="Library.Nat.Properties.html#2686" class="Function">*-assoc</a> <a id="6874" href="Chapter.Logic.Existential.html#6840" class="Bound">v</a> <a id="6876" href="Chapter.Logic.Existential.html#6829" class="Bound">u</a> <a id="6878" class="Symbol">_)</a>
</pre>
<p>Proving that <code class="language-plaintext highlighter-rouge">∣</code> is antisymmetric requires some more work, including
some tedious properties of addition and multiplication. We start by
showing that adding a non-null number <code class="language-plaintext highlighter-rouge">succ y</code> to <code class="language-plaintext highlighter-rouge">x</code> cannot yield
<code class="language-plaintext highlighter-rouge">x</code> and multiplying zero to <code class="language-plaintext highlighter-rouge">x</code> cannot yield <code class="language-plaintext highlighter-rouge">1</code>.</p>

<pre class="Agda"><a id="+-succ-neq"></a><a id="7145" href="Chapter.Logic.Existential.html#7145" class="Function">+-succ-neq</a> <a id="7156" class="Symbol">:</a> <a id="7158" class="Symbol">∀{</a><a id="7160" href="Chapter.Logic.Existential.html#7160" class="Bound">x</a> <a id="7162" href="Chapter.Logic.Existential.html#7162" class="Bound">y</a> <a id="7164" class="Symbol">:</a> <a id="7166" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="7167" class="Symbol">}</a> <a id="7169" class="Symbol">-&gt;</a> <a id="7172" href="Chapter.Logic.Existential.html#7160" class="Bound">x</a> <a id="7174" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="7176" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7181" href="Chapter.Logic.Existential.html#7162" class="Bound">y</a> <a id="7183" href="Library.Equality.html#140" class="Function Operator">!=</a> <a id="7186" href="Chapter.Logic.Existential.html#7160" class="Bound">x</a>
<a id="7188" href="Chapter.Logic.Existential.html#7145" class="Function">+-succ-neq</a> <a id="7199" class="Symbol">{</a><a id="7200" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7205" href="Chapter.Logic.Existential.html#7205" class="Bound">x</a><a id="7206" class="Symbol">}</a> <a id="7208" href="Chapter.Logic.Existential.html#7208" class="Bound">eq</a> <a id="7211" class="Symbol">=</a> <a id="7213" href="Chapter.Logic.Existential.html#7145" class="Function">+-succ-neq</a> <a id="7224" class="Symbol">(</a><a id="7225" href="Library.Nat.Properties.html#157" class="Function">succ-injective</a> <a id="7240" href="Chapter.Logic.Existential.html#7208" class="Bound">eq</a><a id="7242" class="Symbol">)</a>

<a id="*-zero-neq-one"></a><a id="7245" href="Chapter.Logic.Existential.html#7245" class="Function">*-zero-neq-one</a> <a id="7260" class="Symbol">:</a> <a id="7262" class="Symbol">∀(</a><a id="7264" href="Chapter.Logic.Existential.html#7264" class="Bound">x</a> <a id="7266" class="Symbol">:</a> <a id="7268" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="7269" class="Symbol">)</a> <a id="7271" class="Symbol">-&gt;</a> <a id="7274" href="Chapter.Logic.Existential.html#7264" class="Bound">x</a> <a id="7276" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="7278" class="Number">0</a> <a id="7280" href="Library.Equality.html#140" class="Function Operator">!=</a> <a id="7283" class="Number">1</a>
<a id="7285" href="Chapter.Logic.Existential.html#7245" class="Function">*-zero-neq-one</a> <a id="7300" class="Symbol">(</a><a id="7301" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7306" href="Chapter.Logic.Existential.html#7306" class="Bound">x</a><a id="7307" class="Symbol">)</a> <a id="7309" href="Chapter.Logic.Existential.html#7309" class="Bound">eq</a> <a id="7312" class="Symbol">=</a> <a id="7314" href="Chapter.Logic.Existential.html#7245" class="Function">*-zero-neq-one</a> <a id="7329" href="Chapter.Logic.Existential.html#7306" class="Bound">x</a> <a id="7331" href="Chapter.Logic.Existential.html#7309" class="Bound">eq</a>
</pre>
<p>WARNING <code class="language-plaintext highlighter-rouge">!=</code> HAS NOT BEEN DEFINED</p>

<p>Next we show that if the product of two numbers yields <code class="language-plaintext highlighter-rouge">1</code>, then
both numbers must be <code class="language-plaintext highlighter-rouge">1</code>.</p>

<pre class="Agda"><a id="*-one"></a><a id="7470" href="Chapter.Logic.Existential.html#7470" class="Function">*-one</a> <a id="7476" class="Symbol">:</a> <a id="7478" class="Symbol">∀(</a><a id="7480" href="Chapter.Logic.Existential.html#7480" class="Bound">x</a> <a id="7482" href="Chapter.Logic.Existential.html#7482" class="Bound">y</a> <a id="7484" class="Symbol">:</a> <a id="7486" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="7487" class="Symbol">)</a> <a id="7489" class="Symbol">-&gt;</a> <a id="7492" href="Chapter.Logic.Existential.html#7480" class="Bound">x</a> <a id="7494" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="7496" href="Chapter.Logic.Existential.html#7482" class="Bound">y</a> <a id="7498" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="7501" class="Number">1</a> <a id="7503" class="Symbol">-&gt;</a> <a id="7506" href="Chapter.Logic.Existential.html#7480" class="Bound">x</a> <a id="7508" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="7511" class="Number">1</a> <a id="7513" href="Library.Logic.html#1349" class="Function Operator">∧</a> <a id="7515" href="Chapter.Logic.Existential.html#7482" class="Bound">y</a> <a id="7517" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="7520" class="Number">1</a>
<a id="7522" href="Chapter.Logic.Existential.html#7470" class="Function">*-one</a> <a id="7528" class="Symbol">(</a><a id="7529" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7534" href="Chapter.Logic.Existential.html#7534" class="Bound">x</a><a id="7535" class="Symbol">)</a>        <a id="7544" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="7560" href="Chapter.Logic.Existential.html#7560" class="Bound">eq</a> <a id="7563" class="Symbol">=</a> <a id="7565" href="Library.Logic.Laws.html#173" class="Function">ex-falso</a> <a id="7574" class="Symbol">(</a><a id="7575" href="Chapter.Logic.Existential.html#7245" class="Function">*-zero-neq-one</a> <a id="7590" href="Chapter.Logic.Existential.html#7534" class="Bound">x</a> <a id="7592" href="Chapter.Logic.Existential.html#7560" class="Bound">eq</a><a id="7594" class="Symbol">)</a>
<a id="7596" href="Chapter.Logic.Existential.html#7470" class="Function">*-one</a> <a id="7602" class="Symbol">(</a><a id="7603" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7608" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="7612" class="Symbol">)</a>     <a id="7618" class="Symbol">(</a><a id="7619" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7624" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="7628" class="Symbol">)</a>     <a id="7634" href="Chapter.Logic.Existential.html#7634" class="Bound">eq</a> <a id="7637" class="Symbol">=</a> <a id="7639" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="7644" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="7646" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="7651" href="Chapter.Logic.Existential.html#7470" class="Function">*-one</a> <a id="7657" class="Symbol">(</a><a id="7658" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7663" class="Symbol">(</a><a id="7664" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7669" href="Chapter.Logic.Existential.html#7669" class="Bound">x</a><a id="7670" class="Symbol">))</a> <a id="7673" class="Symbol">(</a><a id="7674" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7679" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="7683" class="Symbol">)</a>     <a id="7689" class="Symbol">()</a>
<a id="7692" href="Chapter.Logic.Existential.html#7470" class="Function">*-one</a> <a id="7698" class="Symbol">(</a><a id="7699" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7704" class="Symbol">(</a><a id="7705" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7710" href="Chapter.Logic.Existential.html#7710" class="Bound">x</a><a id="7711" class="Symbol">))</a> <a id="7714" class="Symbol">(</a><a id="7715" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7720" class="Symbol">(</a><a id="7721" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7726" href="Chapter.Logic.Existential.html#7726" class="Bound">y</a><a id="7727" class="Symbol">))</a> <a id="7730" class="Symbol">()</a>
</pre>
<p>Then we prove that if the product of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> yields <code class="language-plaintext highlighter-rouge">y</code>, then
either <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">y</code> is <code class="language-plaintext highlighter-rouge">0</code>.</p>

<pre class="Agda"><a id="*-same"></a><a id="7842" href="Chapter.Logic.Existential.html#7842" class="Function">*-same</a> <a id="7849" class="Symbol">:</a> <a id="7851" class="Symbol">∀(</a><a id="7853" href="Chapter.Logic.Existential.html#7853" class="Bound">x</a> <a id="7855" href="Chapter.Logic.Existential.html#7855" class="Bound">y</a> <a id="7857" class="Symbol">:</a> <a id="7859" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="7860" class="Symbol">)</a> <a id="7862" class="Symbol">-&gt;</a> <a id="7865" href="Chapter.Logic.Existential.html#7853" class="Bound">x</a> <a id="7867" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="7869" href="Chapter.Logic.Existential.html#7855" class="Bound">y</a> <a id="7871" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="7874" href="Chapter.Logic.Existential.html#7855" class="Bound">y</a> <a id="7876" class="Symbol">-&gt;</a> <a id="7879" href="Chapter.Logic.Existential.html#7853" class="Bound">x</a> <a id="7881" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="7884" class="Number">1</a> <a id="7886" href="Library.Logic.html#1416" class="Datatype Operator">∨</a> <a id="7888" href="Chapter.Logic.Existential.html#7855" class="Bound">y</a> <a id="7890" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="7893" class="Number">0</a>
<a id="7895" href="Chapter.Logic.Existential.html#7842" class="Function">*-same</a> <a id="7902" href="Chapter.Logic.Existential.html#7902" class="Bound">x</a>               <a id="7918" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="7927" href="Chapter.Logic.Existential.html#7927" class="Bound">eq</a> <a id="7930" class="Symbol">=</a> <a id="7932" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="7936" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="7941" href="Chapter.Logic.Existential.html#7842" class="Function">*-same</a> <a id="7948" class="Symbol">(</a><a id="7949" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7954" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="7958" class="Symbol">)</a>     <a id="7964" class="Symbol">(</a><a id="7965" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="7970" href="Chapter.Logic.Existential.html#7970" class="Bound">y</a><a id="7971" class="Symbol">)</a> <a id="7973" href="Chapter.Logic.Existential.html#7973" class="Bound">eq</a> <a id="7976" class="Symbol">=</a> <a id="7978" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="7982" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="7987" href="Chapter.Logic.Existential.html#7842" class="Function">*-same</a> <a id="7994" class="Symbol">(</a><a id="7995" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="8000" class="Symbol">(</a><a id="8001" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="8006" href="Chapter.Logic.Existential.html#8006" class="Bound">x</a><a id="8007" class="Symbol">))</a> <a id="8010" class="Symbol">(</a><a id="8011" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="8016" href="Chapter.Logic.Existential.html#8016" class="Bound">y</a><a id="8017" class="Symbol">)</a> <a id="8019" href="Chapter.Logic.Existential.html#8019" class="Bound">eq</a> <a id="8022" class="Symbol">=</a> <a id="8024" href="Library.Logic.Laws.html#173" class="Function">ex-falso</a> <a id="8033" class="Symbol">(</a><a id="8034" href="Chapter.Logic.Existential.html#7145" class="Function">+-succ-neq</a> <a id="8045" class="Symbol">(</a><a id="8046" href="Library.Nat.Properties.html#157" class="Function">succ-injective</a> <a id="8061" href="Chapter.Logic.Existential.html#8019" class="Bound">eq</a><a id="8063" class="Symbol">))</a>
</pre>
<p>We combine these results to prove that <code class="language-plaintext highlighter-rouge">∣</code> is antisymmetric.</p>

<pre class="Agda"><a id="∣-antisymm"></a><a id="8137" href="Chapter.Logic.Existential.html#8137" class="Function">∣-antisymm</a> <a id="8148" class="Symbol">:</a> <a id="8150" class="Symbol">∀{</a><a id="8152" href="Chapter.Logic.Existential.html#8152" class="Bound">x</a> <a id="8154" href="Chapter.Logic.Existential.html#8154" class="Bound">y</a> <a id="8156" class="Symbol">:</a> <a id="8158" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="8159" class="Symbol">}</a> <a id="8161" class="Symbol">-&gt;</a> <a id="8164" href="Chapter.Logic.Existential.html#8152" class="Bound">x</a> <a id="8166" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="8168" href="Chapter.Logic.Existential.html#8154" class="Bound">y</a> <a id="8170" class="Symbol">-&gt;</a> <a id="8173" href="Chapter.Logic.Existential.html#8154" class="Bound">y</a> <a id="8175" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="8177" href="Chapter.Logic.Existential.html#8152" class="Bound">x</a> <a id="8179" class="Symbol">-&gt;</a> <a id="8182" href="Chapter.Logic.Existential.html#8152" class="Bound">x</a> <a id="8184" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="8187" href="Chapter.Logic.Existential.html#8154" class="Bound">y</a>
<a id="8189" href="Chapter.Logic.Existential.html#8137" class="Function">∣-antisymm</a> <a id="8200" class="Symbol">{</a><a id="8201" href="Chapter.Logic.Existential.html#8201" class="Bound">x</a><a id="8202" class="Symbol">}</a> <a id="8204" class="Symbol">(</a><a id="8205" href="Chapter.Logic.Existential.html#8205" class="Bound">u</a> <a id="8207" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="8209" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="8213" class="Symbol">)</a> <a id="8215" class="Symbol">(</a><a id="8216" href="Chapter.Logic.Existential.html#8216" class="Bound">v</a> <a id="8218" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="8220" href="Chapter.Logic.Existential.html#8220" class="Bound">q</a><a id="8221" class="Symbol">)</a> <a id="8223" class="Keyword">with</a> <a id="8228" href="Chapter.Logic.Existential.html#7842" class="Function">*-same</a> <a id="8235" class="Symbol">(</a><a id="8236" href="Chapter.Logic.Existential.html#8216" class="Bound">v</a> <a id="8238" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="8240" href="Chapter.Logic.Existential.html#8205" class="Bound">u</a><a id="8241" class="Symbol">)</a> <a id="8243" href="Chapter.Logic.Existential.html#8201" class="Bound">x</a> <a id="8245" class="Symbol">(</a><a id="8246" href="Library.Equality.html#583" class="Function">subst</a> <a id="8252" class="Symbol">(</a><a id="8253" href="Library.Equality.html#83" class="Datatype Operator">_==</a> <a id="8257" href="Chapter.Logic.Existential.html#8201" class="Bound">x</a><a id="8258" class="Symbol">)</a> <a id="8260" class="Symbol">(</a><a id="8261" href="Library.Nat.Properties.html#2686" class="Function">*-assoc</a> <a id="8269" href="Chapter.Logic.Existential.html#8216" class="Bound">v</a> <a id="8271" href="Chapter.Logic.Existential.html#8205" class="Bound">u</a> <a id="8273" href="Chapter.Logic.Existential.html#8201" class="Bound">x</a><a id="8274" class="Symbol">)</a> <a id="8276" href="Chapter.Logic.Existential.html#8220" class="Bound">q</a><a id="8277" class="Symbol">)</a>
<a id="8279" class="Symbol">...</a> <a id="8283" class="Symbol">|</a> <a id="8285" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="8289" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="8294" class="Symbol">=</a> <a id="8296" href="Library.Nat.Properties.html#1452" class="Function">*-zero-r</a> <a id="8305" class="Bound">u</a>
<a id="8307" class="Symbol">...</a> <a id="8311" class="Symbol">|</a> <a id="8313" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="8317" href="Chapter.Logic.Existential.html#8317" class="Bound">eq</a> <a id="8320" class="Keyword">with</a> <a id="8325" href="Chapter.Logic.Existential.html#7470" class="Function">*-one</a> <a id="8331" class="Bound">v</a> <a id="8333" class="Bound">u</a> <a id="8335" href="Chapter.Logic.Existential.html#8317" class="Bound">eq</a>
<a id="8338" class="Symbol">...</a> <a id="8342" class="Symbol">|</a> <a id="8344" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="8349" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="8351" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="8356" class="Symbol">=</a> <a id="8358" href="Library.Equality.html#226" class="Function">symm</a> <a id="8363" class="Symbol">(</a><a id="8364" href="Library.Nat.Properties.html#1294" class="Function">*-unit-l</a> <a id="8373" class="Bound">x</a><a id="8374" class="Symbol">)</a>
</pre>
<p>By pattern matching on the proof of <code class="language-plaintext highlighter-rouge">x ∣ y</code> we find out a <code class="language-plaintext highlighter-rouge">u</code> such
that <code class="language-plaintext highlighter-rouge">u * x == y</code>. When we pattern match on the proof of <code class="language-plaintext highlighter-rouge">y ∣ x</code> we
also find the witness <code class="language-plaintext highlighter-rouge">v</code> such that <code class="language-plaintext highlighter-rouge">v * y == x</code>. However, we are
unable to also perform case analysis on the proof of this equality
since the <code class="language-plaintext highlighter-rouge">y</code> has been unified with <code class="language-plaintext highlighter-rouge">u * x</code> and <code class="language-plaintext highlighter-rouge">q</code> is actually a
proof of <code class="language-plaintext highlighter-rouge">v * (u * x) == x</code> (the unification fails in this case
because <code class="language-plaintext highlighter-rouge">x</code> occurs on both sides of the equality). We use <code class="language-plaintext highlighter-rouge">subst</code>
(WARNING <code class="language-plaintext highlighter-rouge">subst</code> IS DEFINED LATER) to obtain from <code class="language-plaintext highlighter-rouge">q</code> a proof of the
equality <code class="language-plaintext highlighter-rouge">(v * u) * x == x</code> and now we use <code class="language-plaintext highlighter-rouge">*-same</code> to deduce that
either <code class="language-plaintext highlighter-rouge">v * u</code> is <code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">0</code>. In the latter case we conclude
using the property that <code class="language-plaintext highlighter-rouge">0</code> absorbs multiplication on the right. In
the former case, we use <code class="language-plaintext highlighter-rouge">*-one</code> to deduce that both <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> must
be <code class="language-plaintext highlighter-rouge">1</code> and we conclude using the property that <code class="language-plaintext highlighter-rouge">1</code> is the unit of
multiplication on the left.</p>

<h2 id="exercises">Exercises</h2>

<ol>
  <li>Prove the theorem <code class="language-plaintext highlighter-rouge">pred' : ∀(x : ℕ) -&gt; x == 0 ∨ (∃[ y ] x == succ y)</code>.</li>
  <li>Define the type <code class="language-plaintext highlighter-rouge">ℕ₂</code> of natural numbers greater that <code class="language-plaintext highlighter-rouge">1</code>. Show
that <code class="language-plaintext highlighter-rouge">2</code> (along with a suitable proof) is an element of <code class="language-plaintext highlighter-rouge">ℕ₂</code>. Then define
the succesor on <code class="language-plaintext highlighter-rouge">ℕ₂</code>, namely the function <code class="language-plaintext highlighter-rouge">succ₂ : ℕ₂ -&gt; ℕ₂</code>.</li>
  <li>Prove that if <code class="language-plaintext highlighter-rouge">x</code> divides both <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>, then <code class="language-plaintext highlighter-rouge">x</code> divides
<code class="language-plaintext highlighter-rouge">y + z</code> as well.</li>
  <li>Prove the theorem <code class="language-plaintext highlighter-rouge">∣-not-total : ∃[ x ] ∃[ y ] ¬ (x ∣ y) ∧ ¬ (y ∣ x)</code>.</li>
  <li>Prove the theorem <code class="language-plaintext highlighter-rouge">last-view : ∀{A : Set} (xs : List A) -&gt; xs !=
[] -&gt; ∃[ ys ] ∃[ y ] xs == ys ++ [ y ]</code>.</li>
  <li>Prove the theorem <code class="language-plaintext highlighter-rouge">half : ∀(x : ℕ) -&gt; ∃[ y ] ∃[ z ] x == y * 2 + z
∧ (z == 0 ∨ z == 1)</code>.</li>
</ol>

<pre class="Agda solution"><a id="9948" class="Comment">-- EXERCISE 1</a>

<a id="pred&#39;"></a><a id="9963" href="Chapter.Logic.Existential.html#9963" class="Function">pred&#39;</a> <a id="9969" class="Symbol">:</a> <a id="9971" class="Symbol">∀(</a><a id="9973" href="Chapter.Logic.Existential.html#9973" class="Bound">x</a> <a id="9975" class="Symbol">:</a> <a id="9977" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="9978" class="Symbol">)</a> <a id="9980" class="Symbol">-&gt;</a> <a id="9983" href="Chapter.Logic.Existential.html#9973" class="Bound">x</a> <a id="9985" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="9988" class="Number">0</a> <a id="9990" href="Library.Logic.html#1416" class="Datatype Operator">∨</a> <a id="9992" class="Symbol">(</a><a id="9993" href="Library.Logic.html#632" class="Function">∃[</a> <a id="9996" href="Chapter.Logic.Existential.html#9996" class="Bound">y</a> <a id="9998" href="Library.Logic.html#632" class="Function">]</a> <a id="10000" href="Chapter.Logic.Existential.html#9973" class="Bound">x</a> <a id="10002" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="10005" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10010" href="Chapter.Logic.Existential.html#9996" class="Bound">y</a><a id="10011" class="Symbol">)</a>
<a id="10013" href="Chapter.Logic.Existential.html#9963" class="Function">pred&#39;</a> <a id="10019" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="10028" class="Symbol">=</a> <a id="10030" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="10034" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="10039" href="Chapter.Logic.Existential.html#9963" class="Function">pred&#39;</a> <a id="10045" class="Symbol">(</a><a id="10046" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10051" href="Chapter.Logic.Existential.html#10051" class="Bound">x</a><a id="10052" class="Symbol">)</a> <a id="10054" class="Symbol">=</a> <a id="10056" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="10060" class="Symbol">(</a><a id="10061" href="Chapter.Logic.Existential.html#10051" class="Bound">x</a> <a id="10063" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10065" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="10069" class="Symbol">)</a>

<a id="10072" class="Comment">-- EXERCISE 2</a>

<a id="ℕ₂"></a><a id="10087" href="Chapter.Logic.Existential.html#10087" class="Function">ℕ₂</a> <a id="10090" class="Symbol">:</a> <a id="10092" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="10096" href="Chapter.Logic.Existential.html#10087" class="Function">ℕ₂</a> <a id="10099" class="Symbol">=</a> <a id="10101" href="Library.Logic.html#222" class="Datatype">Σ</a> <a id="10103" href="Library.Nat.html#32" class="Datatype">ℕ</a> <a id="10105" class="Symbol">λ</a> <a id="10107" href="Chapter.Logic.Existential.html#10107" class="Bound">x</a> <a id="10109" class="Symbol">-&gt;</a> <a id="10112" href="Chapter.Logic.Existential.html#10107" class="Bound">x</a> <a id="10114" href="Library.Equality.html#140" class="Function Operator">!=</a> <a id="10117" class="Number">0</a> <a id="10119" href="Library.Logic.html#1349" class="Function Operator">∧</a> <a id="10121" href="Chapter.Logic.Existential.html#10107" class="Bound">x</a> <a id="10123" href="Library.Equality.html#140" class="Function Operator">!=</a> <a id="10126" class="Number">1</a>

<a id="10129" href="Chapter.Logic.Existential.html#10129" class="Function">_</a> <a id="10131" class="Symbol">:</a> <a id="10133" href="Chapter.Logic.Existential.html#10087" class="Function">ℕ₂</a>
<a id="10136" class="Symbol">_</a> <a id="10138" class="Symbol">=</a> <a id="10140" class="Number">2</a> <a id="10142" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10144" class="Symbol">(λ</a> <a id="10147" class="Symbol">())</a> <a id="10151" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10153" class="Symbol">(λ</a> <a id="10156" class="Symbol">())</a>

<a id="succ₂"></a><a id="10161" href="Chapter.Logic.Existential.html#10161" class="Function">succ₂</a> <a id="10167" class="Symbol">:</a> <a id="10169" href="Chapter.Logic.Existential.html#10087" class="Function">ℕ₂</a> <a id="10172" class="Symbol">-&gt;</a> <a id="10175" href="Chapter.Logic.Existential.html#10087" class="Function">ℕ₂</a>
<a id="10178" href="Chapter.Logic.Existential.html#10161" class="Function">succ₂</a> <a id="10184" class="Symbol">(</a><a id="10185" href="Chapter.Logic.Existential.html#10185" class="Bound">x</a> <a id="10187" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10189" href="Chapter.Logic.Existential.html#10189" class="Bound">nzero</a> <a id="10195" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10197" href="Chapter.Logic.Existential.html#10197" class="Bound">none</a><a id="10201" class="Symbol">)</a> <a id="10203" class="Symbol">=</a> <a id="10205" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10210" href="Chapter.Logic.Existential.html#10185" class="Bound">x</a> <a id="10212" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10214" class="Symbol">(λ</a> <a id="10217" class="Symbol">())</a> <a id="10221" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10223" class="Symbol">λ</a> <a id="10225" class="Symbol">{</a> <a id="10227" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="10232" class="Symbol">-&gt;</a> <a id="10235" href="Chapter.Logic.Existential.html#10189" class="Bound">nzero</a> <a id="10241" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="10246" class="Symbol">}</a>

<a id="10249" class="Comment">-- EXERCISE 3</a>

<a id="∣-plus"></a><a id="10264" href="Chapter.Logic.Existential.html#10264" class="Function">∣-plus</a> <a id="10271" class="Symbol">:</a> <a id="10273" class="Symbol">∀{</a><a id="10275" href="Chapter.Logic.Existential.html#10275" class="Bound">x</a> <a id="10277" href="Chapter.Logic.Existential.html#10277" class="Bound">y</a> <a id="10279" href="Chapter.Logic.Existential.html#10279" class="Bound">z</a> <a id="10281" class="Symbol">:</a> <a id="10283" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="10284" class="Symbol">}</a> <a id="10286" class="Symbol">-&gt;</a> <a id="10289" href="Chapter.Logic.Existential.html#10275" class="Bound">x</a> <a id="10291" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="10293" href="Chapter.Logic.Existential.html#10277" class="Bound">y</a> <a id="10295" class="Symbol">-&gt;</a> <a id="10298" href="Chapter.Logic.Existential.html#10275" class="Bound">x</a> <a id="10300" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="10302" href="Chapter.Logic.Existential.html#10279" class="Bound">z</a> <a id="10304" class="Symbol">-&gt;</a> <a id="10307" href="Chapter.Logic.Existential.html#10275" class="Bound">x</a> <a id="10309" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="10311" class="Symbol">(</a><a id="10312" href="Chapter.Logic.Existential.html#10277" class="Bound">y</a> <a id="10314" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="10316" href="Chapter.Logic.Existential.html#10279" class="Bound">z</a><a id="10317" class="Symbol">)</a>
<a id="10319" href="Chapter.Logic.Existential.html#10264" class="Function">∣-plus</a> <a id="10326" class="Symbol">{</a><a id="10327" href="Chapter.Logic.Existential.html#10327" class="Bound">x</a><a id="10328" class="Symbol">}</a> <a id="10330" class="Symbol">(</a><a id="10331" href="Chapter.Logic.Existential.html#10331" class="Bound">u</a> <a id="10333" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10335" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="10339" class="Symbol">)</a> <a id="10341" class="Symbol">(</a><a id="10342" href="Chapter.Logic.Existential.html#10342" class="Bound">v</a> <a id="10344" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10346" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="10350" class="Symbol">)</a> <a id="10352" class="Symbol">=</a> <a id="10354" href="Chapter.Logic.Existential.html#10331" class="Bound">u</a> <a id="10356" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="10358" href="Chapter.Logic.Existential.html#10342" class="Bound">v</a> <a id="10360" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10362" href="Library.Nat.Properties.html#1543" class="Function">*-dist-r</a> <a id="10371" href="Chapter.Logic.Existential.html#10331" class="Bound">u</a> <a id="10373" href="Chapter.Logic.Existential.html#10342" class="Bound">v</a> <a id="10375" href="Chapter.Logic.Existential.html#10327" class="Bound">x</a>

<a id="10378" class="Comment">-- EXERCISE 4</a>

<a id="∣-not-total"></a><a id="10393" href="Chapter.Logic.Existential.html#10393" class="Function">∣-not-total</a> <a id="10405" class="Symbol">:</a> <a id="10407" href="Library.Logic.html#632" class="Function">∃[</a> <a id="10410" href="Chapter.Logic.Existential.html#10410" class="Bound">x</a> <a id="10412" href="Library.Logic.html#632" class="Function">]</a> <a id="10414" href="Library.Logic.html#632" class="Function">∃[</a> <a id="10417" href="Chapter.Logic.Existential.html#10417" class="Bound">y</a> <a id="10419" href="Library.Logic.html#632" class="Function">]</a> <a id="10421" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="10423" class="Symbol">(</a><a id="10424" href="Chapter.Logic.Existential.html#10410" class="Bound">x</a> <a id="10426" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="10428" href="Chapter.Logic.Existential.html#10417" class="Bound">y</a><a id="10429" class="Symbol">)</a> <a id="10431" href="Library.Logic.html#1349" class="Function Operator">∧</a> <a id="10433" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="10435" class="Symbol">(</a><a id="10436" href="Chapter.Logic.Existential.html#10417" class="Bound">y</a> <a id="10438" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="10440" href="Chapter.Logic.Existential.html#10410" class="Bound">x</a><a id="10441" class="Symbol">)</a>
<a id="10443" href="Chapter.Logic.Existential.html#10393" class="Function">∣-not-total</a> <a id="10455" class="Symbol">=</a> <a id="10457" class="Number">2</a> <a id="10459" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10461" class="Number">3</a> <a id="10463" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10465" href="Chapter.Logic.Existential.html#10483" class="Function">f</a> <a id="10467" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10469" href="Chapter.Logic.Existential.html#10556" class="Function">g</a>
  <a id="10473" class="Keyword">where</a>
    <a id="10483" href="Chapter.Logic.Existential.html#10483" class="Function">f</a> <a id="10485" class="Symbol">:</a> <a id="10487" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="10489" class="Symbol">(</a><a id="10490" class="Number">2</a> <a id="10492" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="10494" class="Number">3</a><a id="10495" class="Symbol">)</a>
    <a id="10501" href="Chapter.Logic.Existential.html#10483" class="Function">f</a> <a id="10503" class="Symbol">(</a><a id="10504" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10509" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>     <a id="10518" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10520" class="Symbol">())</a>
    <a id="10528" href="Chapter.Logic.Existential.html#10483" class="Function">f</a> <a id="10530" class="Symbol">(</a><a id="10531" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10536" class="Symbol">(</a><a id="10537" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10542" class="Symbol">_)</a> <a id="10545" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10547" class="Symbol">())</a>

    <a id="10556" href="Chapter.Logic.Existential.html#10556" class="Function">g</a> <a id="10558" class="Symbol">:</a> <a id="10560" href="Library.Logic.html#1496" class="Function Operator">¬</a> <a id="10562" class="Symbol">(</a><a id="10563" class="Number">3</a> <a id="10565" href="Chapter.Logic.Existential.html#5641" class="Function Operator">∣</a> <a id="10567" class="Number">2</a><a id="10568" class="Symbol">)</a>
    <a id="10574" href="Chapter.Logic.Existential.html#10556" class="Function">g</a> <a id="10576" class="Symbol">(</a><a id="10577" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>   <a id="10584" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10586" class="Symbol">())</a>
    <a id="10594" href="Chapter.Logic.Existential.html#10556" class="Function">g</a> <a id="10596" class="Symbol">(</a><a id="10597" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="10602" class="Symbol">_</a> <a id="10604" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10606" class="Symbol">())</a>

<a id="10611" class="Comment">-- EXERCISE 5</a>

<a id="last-view"></a><a id="10626" href="Chapter.Logic.Existential.html#10626" class="Function">last-view</a> <a id="10636" class="Symbol">:</a> <a id="10638" class="Symbol">∀{</a><a id="10640" href="Chapter.Logic.Existential.html#10640" class="Bound">A</a> <a id="10642" class="Symbol">:</a> <a id="10644" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="10647" class="Symbol">}</a> <a id="10649" class="Symbol">(</a><a id="10650" href="Chapter.Logic.Existential.html#10650" class="Bound">xs</a> <a id="10653" class="Symbol">:</a> <a id="10655" href="Library.List.html#84" class="Datatype">List</a> <a id="10660" href="Chapter.Logic.Existential.html#10640" class="Bound">A</a><a id="10661" class="Symbol">)</a> <a id="10663" class="Symbol">-&gt;</a> <a id="10666" href="Chapter.Logic.Existential.html#10650" class="Bound">xs</a> <a id="10669" href="Library.Equality.html#140" class="Function Operator">!=</a> <a id="10672" href="Library.List.html#113" class="InductiveConstructor">[]</a> <a id="10675" class="Symbol">-&gt;</a> <a id="10678" href="Library.Logic.html#632" class="Function">∃[</a> <a id="10681" href="Chapter.Logic.Existential.html#10681" class="Bound">ys</a> <a id="10684" href="Library.Logic.html#632" class="Function">]</a> <a id="10686" href="Library.Logic.html#632" class="Function">∃[</a> <a id="10689" href="Chapter.Logic.Existential.html#10689" class="Bound">y</a> <a id="10691" href="Library.Logic.html#632" class="Function">]</a> <a id="10693" href="Chapter.Logic.Existential.html#10650" class="Bound">xs</a> <a id="10696" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="10699" href="Chapter.Logic.Existential.html#10681" class="Bound">ys</a> <a id="10702" href="Library.List.html#208" class="Function Operator">++</a> <a id="10705" href="Library.List.html#159" class="Function Operator">[</a> <a id="10707" href="Chapter.Logic.Existential.html#10689" class="Bound">y</a> <a id="10709" href="Library.List.html#159" class="Function Operator">]</a>
<a id="10711" href="Chapter.Logic.Existential.html#10626" class="Function">last-view</a> <a id="10721" href="Library.List.html#113" class="InductiveConstructor">[]</a>             <a id="10736" href="Chapter.Logic.Existential.html#10736" class="Bound">nempty</a> <a id="10743" class="Symbol">=</a> <a id="10745" href="Library.Logic.Laws.html#173" class="Function">ex-falso</a> <a id="10754" class="Symbol">(</a><a id="10755" href="Chapter.Logic.Existential.html#10736" class="Bound">nempty</a> <a id="10762" href="Library.Equality.html#125" class="InductiveConstructor">refl</a><a id="10766" class="Symbol">)</a>
<a id="10768" href="Chapter.Logic.Existential.html#10626" class="Function">last-view</a> <a id="10778" class="Symbol">(</a><a id="10779" href="Chapter.Logic.Existential.html#10779" class="Bound">x</a> <a id="10781" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="10784" href="Library.List.html#113" class="InductiveConstructor">[]</a><a id="10786" class="Symbol">)</a>      <a id="10793" href="Chapter.Logic.Existential.html#10793" class="Bound">nempty</a> <a id="10800" class="Symbol">=</a> <a id="10802" href="Library.List.html#113" class="InductiveConstructor">[]</a> <a id="10805" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10807" href="Chapter.Logic.Existential.html#10779" class="Bound">x</a> <a id="10809" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10811" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="10816" href="Chapter.Logic.Existential.html#10626" class="Function">last-view</a> <a id="10826" class="Symbol">(</a><a id="10827" href="Chapter.Logic.Existential.html#10827" class="Bound">x</a> <a id="10829" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="10832" href="Chapter.Logic.Existential.html#10832" class="Bound">z</a> <a id="10834" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="10837" href="Chapter.Logic.Existential.html#10837" class="Bound">xs</a><a id="10839" class="Symbol">)</a> <a id="10841" href="Chapter.Logic.Existential.html#10841" class="Bound">nempty</a> <a id="10848" class="Keyword">with</a> <a id="10853" href="Chapter.Logic.Existential.html#10626" class="Function">last-view</a> <a id="10863" class="Symbol">(</a><a id="10864" href="Chapter.Logic.Existential.html#10832" class="Bound">z</a> <a id="10866" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="10869" href="Chapter.Logic.Existential.html#10837" class="Bound">xs</a><a id="10871" class="Symbol">)</a> <a id="10873" class="Symbol">(λ</a> <a id="10876" class="Symbol">())</a>
<a id="10880" class="Symbol">...</a> <a id="10884" class="Symbol">|</a> <a id="10886" href="Chapter.Logic.Existential.html#10886" class="Bound">ys</a> <a id="10889" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10891" href="Chapter.Logic.Existential.html#10891" class="Bound">y</a> <a id="10893" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10895" href="Chapter.Logic.Existential.html#10895" class="Bound">eq</a> <a id="10898" class="Symbol">=</a> <a id="10900" class="Bound">x</a> <a id="10902" href="Library.List.html#129" class="InductiveConstructor Operator">::</a> <a id="10905" href="Chapter.Logic.Existential.html#10886" class="Bound">ys</a> <a id="10908" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10910" href="Chapter.Logic.Existential.html#10891" class="Bound">y</a> <a id="10912" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="10914" href="Library.Equality.html#373" class="Function">cong</a> <a id="10919" class="Symbol">(</a><a id="10920" class="Bound">x</a> <a id="10922" href="Library.List.html#129" class="InductiveConstructor Operator">::_</a><a id="10925" class="Symbol">)</a> <a id="10927" href="Chapter.Logic.Existential.html#10895" class="Bound">eq</a>

<a id="10931" class="Comment">-- EXERCISE 6</a>

<a id="half"></a><a id="10946" href="Chapter.Logic.Existential.html#10946" class="Function">half</a> <a id="10951" class="Symbol">:</a> <a id="10953" class="Symbol">∀(</a><a id="10955" href="Chapter.Logic.Existential.html#10955" class="Bound">x</a> <a id="10957" class="Symbol">:</a> <a id="10959" href="Library.Nat.html#32" class="Datatype">ℕ</a><a id="10960" class="Symbol">)</a> <a id="10962" class="Symbol">-&gt;</a> <a id="10965" href="Library.Logic.html#632" class="Function">∃[</a> <a id="10968" href="Chapter.Logic.Existential.html#10968" class="Bound">y</a> <a id="10970" href="Library.Logic.html#632" class="Function">]</a> <a id="10972" href="Library.Logic.html#632" class="Function">∃[</a> <a id="10975" href="Chapter.Logic.Existential.html#10975" class="Bound">z</a> <a id="10977" href="Library.Logic.html#632" class="Function">]</a> <a id="10979" href="Chapter.Logic.Existential.html#10955" class="Bound">x</a> <a id="10981" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="10984" href="Chapter.Logic.Existential.html#10968" class="Bound">y</a> <a id="10986" href="Library.Nat.html#293" class="Function Operator">*</a> <a id="10988" class="Number">2</a> <a id="10990" href="Library.Nat.html#145" class="Function Operator">+</a> <a id="10992" href="Chapter.Logic.Existential.html#10975" class="Bound">z</a> <a id="10994" href="Library.Logic.html#1349" class="Function Operator">∧</a> <a id="10996" class="Symbol">(</a><a id="10997" href="Chapter.Logic.Existential.html#10975" class="Bound">z</a> <a id="10999" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="11002" class="Number">0</a> <a id="11004" href="Library.Logic.html#1416" class="Datatype Operator">∨</a> <a id="11006" href="Chapter.Logic.Existential.html#10975" class="Bound">z</a> <a id="11008" href="Library.Equality.html#83" class="Datatype Operator">==</a> <a id="11011" class="Number">1</a><a id="11012" class="Symbol">)</a>
<a id="11014" href="Chapter.Logic.Existential.html#10946" class="Function">half</a> <a id="11019" href="Library.Nat.html#48" class="InductiveConstructor">zero</a>            <a id="11035" class="Symbol">=</a> <a id="11037" href="Library.Nat.html#48" class="InductiveConstructor">zero</a> <a id="11042" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11044" href="Library.Nat.html#48" class="InductiveConstructor">zero</a> <a id="11049" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11051" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="11056" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11058" href="Library.Logic.html#1446" class="InductiveConstructor">inl</a> <a id="11062" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="11067" href="Chapter.Logic.Existential.html#10946" class="Function">half</a> <a id="11072" class="Symbol">(</a><a id="11073" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="11078" href="Library.Nat.html#48" class="InductiveConstructor">zero</a><a id="11082" class="Symbol">)</a>     <a id="11088" class="Symbol">=</a> <a id="11090" href="Library.Nat.html#48" class="InductiveConstructor">zero</a> <a id="11095" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11097" class="Number">1</a> <a id="11099" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11101" href="Library.Equality.html#125" class="InductiveConstructor">refl</a> <a id="11106" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11108" href="Library.Logic.html#1465" class="InductiveConstructor">inr</a> <a id="11112" href="Library.Equality.html#125" class="InductiveConstructor">refl</a>
<a id="11117" href="Chapter.Logic.Existential.html#10946" class="Function">half</a> <a id="11122" class="Symbol">(</a><a id="11123" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="11128" class="Symbol">(</a><a id="11129" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="11134" href="Chapter.Logic.Existential.html#11134" class="Bound">x</a><a id="11135" class="Symbol">))</a> <a id="11138" class="Keyword">with</a> <a id="11143" href="Chapter.Logic.Existential.html#10946" class="Function">half</a> <a id="11148" href="Chapter.Logic.Existential.html#11134" class="Bound">x</a>
<a id="11150" class="Symbol">...</a> <a id="11154" class="Symbol">|</a> <a id="11156" href="Chapter.Logic.Existential.html#11156" class="Bound">y</a> <a id="11158" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11160" href="Chapter.Logic.Existential.html#11160" class="Bound">z</a> <a id="11162" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11164" href="Chapter.Logic.Existential.html#11164" class="Bound">eq</a> <a id="11167" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11169" href="Chapter.Logic.Existential.html#11169" class="Bound">zr</a> <a id="11172" class="Symbol">=</a> <a id="11174" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="11179" href="Chapter.Logic.Existential.html#11156" class="Bound">y</a> <a id="11181" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11183" href="Chapter.Logic.Existential.html#11160" class="Bound">z</a> <a id="11185" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11187" href="Library.Equality.html#373" class="Function">cong</a> <a id="11192" class="Symbol">(</a><a id="11193" href="Library.Nat.html#59" class="InductiveConstructor">succ</a> <a id="11198" href="Library.Fun.html#112" class="Function Operator">∘</a> <a id="11200" href="Library.Nat.html#59" class="InductiveConstructor">succ</a><a id="11204" class="Symbol">)</a> <a id="11206" href="Chapter.Logic.Existential.html#11164" class="Bound">eq</a> <a id="11209" href="Library.Logic.html#271" class="InductiveConstructor Operator">,</a> <a id="11211" href="Chapter.Logic.Existential.html#11169" class="Bound">zr</a>
</pre>

  </div>
  <ul class="menu">
  <li>
    <a href="Chapter.Logic.Negation.html">‹ Negation and decidability</a></li>
  <li>
    <a href="Chapter.Logic.Predicates.html">Defining predicates ›</a></li>
</ul>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>
  <div class="wrapper">
    <!-- <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"> -->
    <!--   <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"/> -->
    <!-- </a> -->
    2022-2023
    <a href="https://boystrange.github.io">Luca Padovani</a>
    and <a href="http://www.di.unito.it/~deligu/">Ugo de'Liguoro</a>.
    Page generated on 20 Sep 2023.
  </div>
</footer>
</body>

</html>
